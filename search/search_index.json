{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"About%20Me/","title":"About Me","text":"<p>Soy Danna Paola Garc\u00eda S\u00e1nchez, estudiante de Mecatr\u00f3nica en 5\u00ba semestre.  </p> <p>Me considero una persona curiosa, creativa y perseverante. Disfruto aprender nuevas herramientas, trabajar en equipo y aplicar mis conocimientos en proyectos, me gusta aprender para combinar mis conocimientos en el futuro. </p>"},{"location":"Ejemplos/comandosgit/","title":"\ud83d\ude80 Comandos b\u00e1sicos de Git (primeros pasos)","text":"<p>En este curso solo usaremos los comandos esenciales de Git para trabajar con repositorios.</p>"},{"location":"Ejemplos/comandosgit/#1-clonar-un-repositorio","title":"1. Clonar un repositorio","text":"<p>Copia un proyecto de GitHub a tu computadora.</p> <pre><code>git clone https://github.com/usuario/repositorio.git\n</code></pre>"},{"location":"Ejemplos/comandosgit/#2-verificar-cambios","title":"2. Verificar cambios","text":"<p>Muestra qu\u00e9 archivos has modificado o agregado.</p> <pre><code>git status\n</code></pre>"},{"location":"Ejemplos/comandosgit/#3-preparar-cambios","title":"3. Preparar cambios","text":"<p>Agrega archivos para guardarlos en el pr\u00f3ximo commit.</p> <pre><code>git add archivo.txt\ngit add .   # agrega todos los archivos modificados\n</code></pre>"},{"location":"Ejemplos/comandosgit/#4-guardar-cambios-commit","title":"4. Guardar cambios (commit)","text":"<p>Guarda tus cambios con un mensaje descriptivo.</p> <pre><code>git commit -m \"Descripci\u00f3n breve de los cambios\"\n</code></pre>"},{"location":"Ejemplos/comandosgit/#5-subir-cambios-al-repositorio-push","title":"5. Subir cambios al repositorio (push)","text":"<p>Env\u00eda tus commits locales al repositorio en GitHub.</p> <pre><code>git push origin main\n</code></pre>"},{"location":"Ejemplos/comandosgit/#6-traer-cambios-del-remoto-pull","title":"6. Traer cambios del remoto (pull)","text":"<p>Actualiza tu proyecto con los \u00faltimos cambios de GitHub.</p> <pre><code>git pull origin main\n</code></pre>"},{"location":"Ejemplos/comandosgit/#flujo-tipico-de-trabajo","title":"Flujo t\u00edpico de trabajo","text":"<ol> <li> <p>Traer cambios del remoto <pre><code>git pull origin main\n</code></pre></p> </li> <li> <p>Editar tus archivos de proyecto.</p> </li> <li> <p>Preparar los cambios <pre><code>git add .\n</code></pre></p> </li> <li> <p>Guardar los cambios <pre><code>git commit -m \"Mensaje descriptivo\"\n</code></pre></p> </li> <li> <p>Enviar los cambios al remoto <pre><code>git push origin main\n</code></pre></p> </li> </ol> <p>Consejo</p> <p>Piensa en este ciclo como un loop infinito: cada vez que quieras contribuir \u2192 primero <code>pull</code>, despu\u00e9s <code>add</code> + <code>commit</code>, y finalmente <code>push</code>.</p>"},{"location":"Ejemplos/ejemplo1/","title":"\ud83d\udcda Ejemplo de Documentaci\u00f3n del Proyecto","text":"<p>Plantilla gen\u00e9rica para documentar proyectos acad\u00e9micos o de ingenier\u00eda. Copia y adapta las secciones seg\u00fan tu necesidad.</p>"},{"location":"Ejemplos/ejemplo1/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"Ejemplos/ejemplo1/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"Ejemplos/ejemplo1/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"Ejemplos/ejemplo1/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"Ejemplos/ejemplo1/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"Ejemplos/encabezados/","title":"Encabezados","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"Ejemplos/encabezados/#titulo-h1","title":"T\u00edtulo H1","text":""},{"location":"Ejemplos/encabezados/#titulo-h2m","title":"T\u00edtulo H2m","text":""},{"location":"Ejemplos/encabezados/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"Ejemplos/encabezados/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"Ejemplos/encabezados/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"Ejemplos/encabezados/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"Ejemplos/encabezados/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"Ejemplos/encabezados/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"Ejemplos/encabezados/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](../recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"Ejemplos/encabezados/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](..recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Ejemplos/encabezados/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"Ejemplos/encabezados/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"Ejemplos/encabezados/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"Ejemplos/encabezados/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"Ejemplos/encabezados/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"Ejemplos/principal/","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"Ejemplos/principal/#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"Proyectos_IV/Entrega_Final/","title":"Entrega Final","text":""},{"location":"Proyectos_IV/Entrega_Final/#1presentacion","title":"1)Presentaci\u00f3n","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_IV/Entrega_Final/#2documento","title":"2)Documento","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_IV/Semana1/","title":"Semana 1","text":""},{"location":"Proyectos_IV/Semana1/#1-nivel-de-madurez-tecnologica-trl","title":"1) Nivel de Madurez Tecnol\u00f3gica (TRL)","text":"<p>El Technology Readiness Level (TRL) es un sistema que clasifica el grado de desarrollo que presenta una tecnolog\u00eda en un momento espec\u00edfico.</p> <p>Esta escala permite determinar si una idea tecnol\u00f3gica se encuentra en una fase conceptual, si ya puede probarse en laboratorio o si est\u00e1 lo suficientemente desarrollada para operar en condiciones reales y avanzar hacia su comercializaci\u00f3n.</p> <p>La escala TRL est\u00e1 compuesta por 9 niveles, que van desde la investigaci\u00f3n fundamental (TRL1) hasta la implementaci\u00f3n completa de la tecnolog\u00eda en el mercado (TRL9).</p> <p></p>"},{"location":"Proyectos_IV/Semana1/#trl1","title":"TRL1","text":"<p>Debemos realizar una investigaci\u00f3n b\u00e1sica sobre nuestra idea, buscar art\u00edculos cient\u00edficos publicados que respalden nuestra idea.</p>"},{"location":"Proyectos_IV/Semana1/#trl2","title":"TRL2","text":"<p>B\u00fasqueda de patentes, investigar lo necesario para que realicemos el prototipo, buscar usuarios que se beneficiaran con esta idea, hacer el plan de licenciamiento.</p>"},{"location":"Proyectos_IV/Semana1/#trl3","title":"TRL3","text":"<p>Realizar pruebas experimentales, identificar los componentes para el bast\u00f3n, investigaci\u00f3n de los aspectos regulatorios.</p>"},{"location":"Proyectos_IV/Semana1/#trl4","title":"TRL4","text":"<p>Integraci\u00f3n de los componentes principales, validaci\u00f3n de mercado, funcionabilidad a nivel laboratorio, identificar riesgos tecnol\u00f3gicos, de mercado y financieros.</p>"},{"location":"Proyectos_IV/Semana1/#2-syllabus","title":"2) Syllabus","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_IV/Semana1/#3-boceto","title":"3) Boceto","text":""},{"location":"Proyectos_IV/Semana3/","title":"Semana 3","text":""},{"location":"Proyectos_IV/Semana3/#1-presentacion","title":"1) Presentaci\u00f3n","text":"<p>Esta presentaci\u00f3n junta dos tareas en un mismo archivo. En la primera parte se explica de forma general c\u00f3mo ha ido cambiando la forma de preparar caf\u00e9 hasta llegar a las m\u00e1quinas de c\u00e1psulas, usando Nespresso como ejemplo de una marca que destaca por su sistema de c\u00e1psulas y la experiencia que da al usuario. En la segunda parte se muestra mi proyecto, donde primero se describe la problem\u00e1tica que quiero resolver y despu\u00e9s se explican los pasos b\u00e1sicos del prototipo: elegir los componentes m\u00e1s adecuados, probar que los sensores funcionen bien dentro del pato sin da\u00f1arse por el agua o la humedad, y comparar sus lecturas con mediciones de referencia en un ambiente controlado.</p> <p>Presentaci\u00f3n (PDF)</p>"},{"location":"Proyectos_IV/Semana4/","title":"Semana 4","text":""},{"location":"Proyectos_IV/Semana4/#1-diagrama-de-gantt","title":"1) Diagrama de Gantt","text":"<p>Durante esta semana construimos un diagrama de Gantt para ordenar de forma clara las actividades necesarias para completar el proyecto y asignarles un intervalo de tiempo espec\u00edfico a cada una, con la intenci\u00f3n de hacer m\u00e1s eficiente el desarrollo del producto final.</p> <p>En esta secci\u00f3n se muestra el diagrama de Gantt del proyecto. Esta herramienta permite organizar las actividades en una l\u00ednea de tiempo, indicando cu\u00e1ndo inicia y termina cada tarea. Gracias a esto podemos visualizar el orden de las actividades, qu\u00e9 cosas se hacen en paralelo y el tiempo estimado para llegar al producto final, facilitando el seguimiento y control del avance del proyecto.</p> <p>Ver gr\u00e1fico de Gantt</p>    Tu navegador no soporta iframes."},{"location":"Proyectos_IV/Semana5/","title":"Semana 5","text":""},{"location":"Proyectos_IV/Semana5/#1-marco-real-ganar-vale-la-pena-aplicado-a-su-proyecto","title":"1) Marco \u201creal-ganar-vale la pena\u201d aplicado a su proyecto","text":"<p>El objetivo de esta tarea es que reflexionen si de verdad existe el problema que creen haber identificado y si vale la pena resolverlo.  De igual forma que determinen si realmente tienen un producto que tendr\u00e1 clientes que pagar\u00e1n por su soluci\u00f3n. </p>"},{"location":"Proyectos_IV/Semana5/#que-es-un-marco-real-ganar-vale-la-pena","title":"\u00bfQu\u00e9 es un marco \"Real-Ganar-Vale la pena\"","text":"<p>Un Marco \"real-ganar-vale la pena\" (Real-Win-Worth it o RGW) es una herramienta de evaluaci\u00f3n desarrollada por 3M para analizar la viabilidad de una idea o producto en tres frentes: que sea real, que se pueda ganar y que valga la pena. Este m\u00e9todo ayuda a las empresas a filtrar y seleccionar las ideas m\u00e1s prometedoras para el desarrollo, asegurando que la idea sea viable en el mercado y que pueda generar beneficios.</p> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_IV/Semana6/","title":"Semana 6","text":""},{"location":"Proyectos_IV/Semana6/#1definir-quien-es-el-cliente-de-tu-proyecto-y-el-tamano-de-ese-mercado","title":"1)Definir qui\u00e9n es el cliente de tu proyecto y el tama\u00f1o de ese mercado","text":"<ol> <li> <p>Hogares con alberca    Familias con alberca propia que buscan monitorear la calidad del agua de forma r\u00e1pida y sencilla para garantizar que sea segura para nadar.</p> </li> <li> <p>Hoteles, resorts y clubes    Es un gran mercado debido a la alta cantidad de hoteles que se encuentran en M\u00e9xico. Estos espacios requieren cumplir normas de salubridad y mantener la confianza de sus clientes mediante un monitoreo constante de la calidad del agua.</p> </li> <li> <p>Parques y espacios recreativos con lagos (p\u00fablicos o privados)    Administraciones que necesitan mantener la calidad del agua en lagos y cuerpos recreativos para actividades deportivas, culturales o tur\u00edsticas.</p> </li> <li> <p>Gobierno (municipal, estatal y federal) </p> </li> <li>Monitoreo de cuerpos de agua: r\u00edos, lagos, presas.  </li> <li>Programas de saneamiento y control de contaminaci\u00f3n.  </li> <li>Proyectos de sustentabilidad y gesti\u00f3n ambiental.  </li> <li>Permite contar con datos confiables en tiempo real para la toma de decisiones y pol\u00edticas p\u00fablicas.</li> </ol>"},{"location":"Proyectos_IV/Semana6/#2analisis-de-las-5-fuerzas-de-porter","title":"2)An\u00e1lisis de las 5 fuerzas de Porter","text":"<p>El an\u00e1lisis de las 5 fuerzas de Porter explora el entorno competitivo en el que se inserta el proyecto. A trav\u00e9s de este modelo se revisa el poder de los proveedores y clientes, la intensidad de la competencia, la amenaza de productos sustitutos y la posible entrada de nuevos competidores, para evaluar qu\u00e9 tan atractivo, riesgoso o retador es el mercado objetivo.</p> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_IV/Semana6/#3tabla-creando-valor","title":"3)Tabla Creando Valor","text":"<p>En la tabla de creando valor se desglosa c\u00f3mo se genera realmente ese valor en la pr\u00e1ctica. Se muestran las actividades, recursos, componentes del prototipo y decisiones de dise\u00f1o que hacen posible la propuesta de valor, conectando cada elemento del proyecto con el beneficio concreto que recibe el usuario.</p> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_IV/Semana6/#4tabla-propuesta-de-valor","title":"4)Tabla Propuesta de Valor","text":"<p>La tabla de propuesta de valor resume de forma clara qu\u00e9 ofrece mi proyecto, a qui\u00e9n est\u00e1 dirigido y qu\u00e9 problema espec\u00edfico resuelve. Ah\u00ed se explica por qu\u00e9 la soluci\u00f3n es relevante para el usuario y en qu\u00e9 se diferencia de otras alternativas, ya sea por sus beneficios funcionales, su experiencia de uso o el impacto que genera.</p> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_IV/Semana6/#5-propuesta-de-valor","title":"5) Propuesta de Valor","text":"<p>Olv\u00eddate de complicaciones y pruebas costosas. Con nuestro sistema sabes al instante c\u00f3mo est\u00e1 tu agua y con esto prev\u00e9 los problemas.</p>"},{"location":"Proyectos_IV/Semana7/","title":"Semana 7","text":""},{"location":"Proyectos_IV/Semana7/#1costo-del-proyecto","title":"1)Costo del proyecto","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"Proyectos_IV/Semana7/#2costo-del-proyecto-tabla","title":"2)Costo del proyecto tabla","text":""},{"location":"Proyectos_IV/Semana7/#3trello","title":"3)Trello","text":"<p>En este proyecto utilizamos Trello como herramienta de organizaci\u00f3n de tareas. Creamos tarjetas para cada actividad y las fuimos moviendo entre las columnas To Do, Doing y Done, lo que nos permiti\u00f3 visualizar qu\u00e9 faltaba por hacer, qu\u00e9 estaba en proceso y qu\u00e9 ya estaba terminado, facilitando el seguimiento del avance del equipo.</p> <p>Tablero de Trello \u2013 Citizen Quack</p>"},{"location":"Proyectos_IV/Semana8/","title":"Semana 8","text":""},{"location":"Proyectos_IV/Semana8/#1patentes","title":"1)Patentes","text":"<p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"SE_1/Examen1/","title":"Examen 1","text":""},{"location":"SE_1/Examen1/#1-reto-simon-dice-4-colores-rp-pico-2","title":"1) Reto: Sim\u00f3n Dice (4 colores) \u2013 RP Pico 2","text":"<p>Construir un juego Sim\u00f3n Dice de 4 colores en Raspberry Pi Pico 2.</p> <ul> <li>La secuencia crece +1 por ronda, de 1 hasta 15.  </li> <li>La persona jugadora debe repetir la secuencia con 4 botones dentro de un tiempo l\u00edmite por ronda.  </li> <li>Tiempo l\u00edmite por ronda (fase de entrada): TL = longitud + 5 segundos (p. ej., Ronda 7 \u2192 12 s).  </li> <li>Puntaje (0\u201315): mostrar la m\u00e1xima ronda alcanzada en un display de 7 segmentos en hex (0\u20139, A, b, C, d, E, F).  </li> <li>Aleatoriedad obligatoria: la secuencia debe ser impredecible en cada ejecuci\u00f3n.  </li> </ul> <p>Reglas del juego (obligatorias)</p> <ol> <li>Encendido/Reset: el 7 segmentos muestra \u201c0\u201d y queda en espera de Start (cualquier bot\u00f3n permite iniciar).  </li> <li>Reproducci\u00f3n: mostrar la secuencia actual (LEDs uno por uno con separaci\u00f3n clara).  </li> <li>Entrada: al terminar la reproducci\u00f3n, la persona debe repetir la secuencia completa dentro de TL.  </li> <li>Fallo (Game Over): bot\u00f3n incorrecto, falta/extra de entradas o exceder TL.  </li> <li>Progresi\u00f3n: si acierta, puntaje = n\u00famero de ronda, agrega 1 color aleatorio y avanza.  </li> <li>Fin: al fallar o completar la Ronda 15. Mostrar puntaje final en 7 segmentos (hex).  </li> </ol> <p>C\u00f3digo</p> <p><pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n#include &lt;stdlib.h&gt;  //Para la funcion de rand y srand\n#include \"pico/time.h\"// Para utilizar el tiempo\n\n //DEFINIR LOS LEDS Y LOS BOTONES\n#define LED_RO 0\n#define LED_AZ 1\n#define LED_VE 2\n#define LED_AM 3\n\n#define Boton_RO 18\n#define Boton_AZ 19\n#define Boton_VE 17\n#define Boton_AM 16\n\nint Rondas = 15; //N\u00famero de rondas\nint Secuencia[15];//Tama\u00f1o del array para guardar la secuencia\n\nint leer_boton() {     //Funcion para leer el boton\n    while (true) {\n        if (gpio_get(Boton_RO)) {\n              while (gpio_get(Boton_RO)){ sleep_ms(10); // Para evitar rebotes se espera y se devuelve el valor del led\n              return LED_RO;\n            }\n        }\n        if (gpio_get(Boton_AZ)) {\n              while (gpio_get(Boton_AZ)){ sleep_ms(10);\n              return LED_AZ;\n            }\n        }\n        if (gpio_get(Boton_VE)) {\n              while (gpio_get(Boton_VE)){ sleep_ms(10);\n              return LED_VE;\n            }\n        }\n        if (gpio_get(Boton_AM)) {\n              while (gpio_get(Boton_AM)){ sleep_ms(10);\n              return LED_AM;\n            }\n        }\n    }\n}\n\nint main() {\n    // Inicializar LEDS como salidas\n    gpio_init(LED_RO); gpio_set_dir(LED_RO, 1);\n    gpio_init(LED_AZ); gpio_set_dir(LED_AZ, 1);\n    gpio_init(LED_VE); gpio_set_dir(LED_VE, 1);\n    gpio_init(LED_AM); gpio_set_dir(LED_AM, 1);\n\n    // Inicializar botones como entradas\n    gpio_init(Boton_RO); gpio_set_dir(Boton_RO, 0);\n    gpio_init(Boton_AZ); gpio_set_dir(Boton_AZ, 0);\n    gpio_init(Boton_VE); gpio_set_dir(Boton_VE, 0);\n    gpio_init(Boton_AM); gpio_set_dir(Boton_AM, 0);\n\n    //Mientras que ninguno de los botones este presionado, todos los leds van a estar apagados\n    while (gpio_get(Boton_RO) == 0 &amp;&amp; gpio_get(Boton_AZ) == 0 &amp;&amp; gpio_get(Boton_VE) == 0 &amp;&amp; gpio_get(Boton_AM) == 0) {\n        gpio_put(LED_RO, 0);\n        gpio_put(LED_AZ, 0);\n        gpio_put(LED_VE, 0);\n        gpio_put(LED_AM, 0);\n        sleep_ms(1);\n    }\n\n    //La semilla para los numeros aleatorios usando el tiempo para que nuestra secuencia sea diferente cada vez\n    srand(time_us_32());\n\n    // Se repite hasta que lleguemos a las 15 rondas    \n    for (int i = 0; i &lt; Rondas; i++) {\n\n        int led_on = rand() % 4;  // Para que nos de un numero del 0 al 3\n\n        if (led_on == 0) Secuencia[i] = LED_RO;  // Se guarda en el array la secuencia, si es 0 es rojo\n\n        else if (led_on == 1) Secuencia[i] = LED_AZ;\n\n        else if (led_on == 2) Secuencia[i] = LED_VE;\n\n        else if (led_on == 3) Secuencia[i] = LED_AM;\n    }\n\n    bool fallo = false; // Variable para controlar si el jugador ha fallado, false si no ha fallado, true si ha fallado\n\n    // Juego principal se repite hasta que se acaben las rondas o haya un fallo\n    for (int ronda = 0; ronda &lt; Rondas &amp;&amp; !fallo; ronda++) {\n        // Se muestra la secuencia, segun lo que se tenga guardado en el array\n        for (int i = 0; i &lt;= ronda; i++) {\n            int led = Secuencia[i];  // Encender el led correspondiente\n            gpio_put(led, 1); sleep_ms(500);\n            gpio_put(led, 0); sleep_ms(500);\n        }\n\n        // El jugador debe repetir la secuencia, se enciende el led que ha pulsado\n        for (int i = 0; i &lt;= ronda; i++) {\n            int pulsado = leer_boton();\n            gpio_put(pulsado, 1); sleep_ms(200);\n            gpio_put(pulsado, 0); sleep_ms(100);\n\n            // Comprobar si ha fallado la secuencia\n            if (pulsado != Secuencia[i]) { //si el led pulsado no es igual al de la secuencia, ha fallado, por lo que se cambia el valor de fallo a true y se sale del bucle\n                fallo = true;\n                break;\n            }\n        }\n        sleep_ms(800);\n    }\n\n    // Si hubo fallo, parpadear todos los leds 4 veces\n    if (fallo) {\n        for (int k = 0; k &lt; 4; k++) {\n            gpio_put(LED_RO, 1); gpio_put(LED_AZ, 1);\n            gpio_put(LED_VE, 1); gpio_put(LED_AM, 1);\n            sleep_ms(200);\n            gpio_put(LED_RO, 0); gpio_put(LED_AZ, 0);\n            gpio_put(LED_VE, 0); gpio_put(LED_AM, 0);\n            sleep_ms(200);\n        }\n    }\n\n    // Apagar todo\n    gpio_put(LED_RO, 0);\n    gpio_put(LED_AZ, 0);\n    gpio_put(LED_VE, 0);\n    gpio_put(LED_AM, 0);\n\n    while (true){\n      tight_loop_contents(); // Mantener el programa corriendo\n    }\n\n}\n</code></pre> Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p> <p>Ver video en YouTube</p>"},{"location":"SE_1/Examen2/","title":"Examen 2","text":""},{"location":"SE_1/Examen2/#1-control-de-servomotores-con-comandos","title":"1) Control de Servomotores con comandos","text":""},{"location":"SE_1/Examen2/#hardware-minimo","title":"Hardware m\u00ednimo","text":"<p>1 \u00d7 servomotor en un pin PWM (50 Hz).</p> <p>3 \u00d7 botones:</p> <ul> <li>BTN_MODE: cambia el modo activo (c\u00edclico: Entrenamiento \u2192 Continuo \u2192 Step \u2192 \u2026).</li> <li>BTN_NEXT: avanza a la siguiente posici\u00f3n (s\u00f3lo en Step).</li> <li>BTN_PREV: retrocede a la posici\u00f3n anterior (s\u00f3lo en Step).</li> </ul> <p>Pi Pico 2</p>"},{"location":"SE_1/Examen2/#modos-de-operacion","title":"Modos de operaci\u00f3n","text":""},{"location":"SE_1/Examen2/#1-modo-entrenamiento","title":"1) Modo Entrenamiento","text":"<p>Se recibe texto por USB-serial con los comandos siguientes (se aceptan min\u00fasculas/may\u00fasculas indistintamente y tambi\u00e9n sus alias en ingl\u00e9s):</p>"},{"location":"SE_1/Examen2/#borrar-alias-clear-borrar","title":"Borrar (alias: clear, borrar)","text":"<p>Sintaxis: <code>Borrar</code></p> <p>Efecto: elimina la lista completa de posiciones.</p> <p>Respuesta: <code>OK</code></p>"},{"location":"SE_1/Examen2/#escribir-alias-write-escribir","title":"Escribir (alias: write, escribir)","text":"<p>Sintaxis: <code>Escribir, v1, v2, ..., vn</code></p> <p><code>vi</code> son enteros en 0\u2013180.</p> <p>Efecto: sobrescribe la lista con los valores dados en ese orden.</p> <p>Respuesta: OK si todos son v\u00e1lidos y la lista de posiciones; si alguno est\u00e1 fuera de rango o la lista queda vac\u00eda \u2192 <code>Error argumento invalido</code></p>"},{"location":"SE_1/Examen2/#reemplazar-alias-replace-reemplazar","title":"Reemplazar (alias: replace, reemplazar)","text":"<p>Sintaxis: <code>Reemplazar, i, v</code></p> <p>\u00cdndice <code>i</code> en base 1 (1 = primera posici\u00f3n).</p> <p><code>v</code> en 0\u2013180.</p> <p>Efecto: reemplaza el elemento <code>i</code> por <code>v</code>.</p> <p>Respuesta: OK. Si <code>i</code> no existe \u2192 <code>Error indice invalido</code>. Si <code>v</code> fuera de rango \u2192 <code>Error argumento invalido</code>.</p>"},{"location":"SE_1/Examen2/#2-modo-continuo","title":"2) Modo Continuo","text":"<p>Recorre todas las posiciones de la lista en orden, moviendo el servo e imprimiendo cada 1.5 s:</p> <p>Formato: <code>posX: V</code> (por ejemplo, <code>pos1: 90</code>), donde X es base 1.</p> <p>Si la lista est\u00e1 vac\u00eda: imprimir cada 1.5 s <code>Error no hay pos</code> y no mover el servo.</p> <p>Al cambiar a otro modo, el ciclo se detiene inmediatamente.</p>"},{"location":"SE_1/Examen2/#3-modo-step","title":"3) Modo Step","text":"<p>BTN_NEXT: avanza una posici\u00f3n (si ya est\u00e1 en la \u00faltima, se mantiene en esa \u00faltima).</p> <p>BTN_PREV: retrocede una posici\u00f3n (si ya est\u00e1 en la primera, se mantiene en la primera).</p> <p>En cada cambio de posici\u00f3n:</p> <ul> <li>mover el servo a la posici\u00f3n seleccionada;  </li> <li>imprimir <code>posX: V</code>.</li> </ul> <p>Si la lista est\u00e1 vac\u00eda: al presionar BTN_NEXT o BTN_PREV, imprimir <code>Error no hay pos</code> y no mover el servo.</p>"},{"location":"SE_1/Examen2/#info-importante","title":"INFO IMPORTANTE","text":"<p>El movimiento de un servo requiere:</p> <ul> <li>Alimentaci\u00f3n: 5\u20136 V  </li> <li>Se\u00f1al de control: PWM a 50 Hz  </li> <li>Pulso: 1\u20132 ms (representa 0\u2013180 grados)</li> </ul> <p>C\u00f3digo</p> <pre><code>#include \"pico/stdlib.h\"    // Funciones b\u00e1sicas del RP2040\n#include \"hardware/pwm.h\"   // Control PWM para el servo\n#include &lt;stdio.h&gt;         // Entrada/salida est\u00e1ndar\n#include &lt;string&gt;          // Manejo de strings para comandos\nusing namespace std;\n\n// Definici\u00f3n de pines GPIO\n#define BUTTON_MODE 14     // Pin para bot\u00f3n de cambio de modo\n#define BOTON_NEXT 13     // Pin para bot\u00f3n de avanzar posici\u00f3n\n#define BOTON_PREV 11     // Pin para bot\u00f3n de retroceder posici\u00f3n\n#define SERVO_PIN 1      // Pin para la se\u00f1al PWM del servo\n\n// Variables para control de modo y estado de botones\n// volatile: pueden cambiar en ISR\nvolatile int modo = 1;                         // Modo actual (1-3)\nvolatile bool boton_modo_presionado = false;   // Estado del bot\u00f3n modo\nvolatile bool boton_next_presionado = false;   // Estado del bot\u00f3n next\nvolatile bool boton_prev_presionado = false;   // Estado del bot\u00f3n prev\n\n// Variables para el control de la lista de posiciones\nstring comando = \"\";       // Almacena el comando actual siendo ingresado\nint lista[10];            // Arreglo de posiciones del servo (0-180 grados)\nint cantidad = 0;         // Cantidad actual de posiciones guardadas\nuint slice_num;           // N\u00famero de slice PWM asignado al servo\n\nvoid cambio_modo(uint gpio, uint32_t events) {\n    // Variables de tiempo para el debouncing\n    static uint32_t last_time = 0;     // \u00daltimo tiempo de activaci\u00f3n (persiste entre llamadas)\n    uint32_t now = to_ms_since_boot(get_absolute_time());  // Tiempo actual\n\n    // Implementaci\u00f3n de debounce por software\n    if (now - last_time &lt; 200)         // Si han pasado menos de 200ms\n        return;                        // Ignora la interrupci\u00f3n (probablemente rebote)\n    last_time = now;                  // Actualiza el tiempo de \u00faltima activaci\u00f3n v\u00e1lida\n\n    // Identifica qu\u00e9 bot\u00f3n caus\u00f3 la interrupci\u00f3n y activa su bandera\n    if (gpio == BUTTON_MODE)          // \u00bfFue el bot\u00f3n de modo?\n        boton_modo_presionado = true;\n    else if (gpio == BOTON_NEXT)      // \u00bfFue el bot\u00f3n siguiente?\n        boton_next_presionado = true;\n    else if (gpio == BOTON_PREV)      // \u00bfFue el bot\u00f3n anterior?\n        boton_prev_presionado = true;\n}\n\n\nvoid configurar_servo() {\n    // Configura el pin como salida PWM\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n\n    // Obtiene el n\u00famero de slice PWM asignado al pin\n    slice_num = pwm_gpio_to_slice_num(SERVO_PIN);\n\n    // Divisor de clock para ticks de 1\u00b5s (125MHz/125 = 1MHz)\n    pwm_set_clkdiv(slice_num, 125.0f);\n\n    // Configura periodo de 20ms (20000\u00b5s) para frecuencia de 50Hz\n    pwm_set_wrap(slice_num, 20000);\n\n    // Habilita la salida PWM\n    pwm_set_enabled(slice_num, true);\n}\n\n// Funci\u00f3n para mover el servo a un \u00e1ngulo espec\u00edfico\nvoid mover_servo(int angulo) {\n    // Limita el \u00e1ngulo al rango v\u00e1lido\n    if (angulo &lt; 0) angulo = 0;        // No permitir \u00e1ngulos negativos\n    if (angulo &gt; 180) angulo = 180;    // No permitir \u00e1ngulos mayores a 180\n\n    // Convierte \u00e1ngulo a ancho de pulso:\n    // - M\u00ednimo: 500\u00b5s (0 grados)\n    // - M\u00e1ximo: 2500\u00b5s (180 grados)\n    int pulso_us = 500 + (angulo * 2000) / 180;\n\n    // Aplica el ancho de pulso al PWM\n    pwm_set_gpio_level(SERVO_PIN, pulso_us);\n\n    // Muestra el \u00e1ngulo actual por consola\n    printf(\"Servo en %d\u00b0\\n\", angulo);\n}\n /* La f\u00f3rmula mapea linealmente el \u00e1ngulo al ancho de pulso:\n * pulso = 500 + (angulo * 2000)/180\n *\n * La funci\u00f3n limita el \u00e1ngulo al rango v\u00e1lido y muestra feedback por serial\n */\n\nvoid modo1() {\n    // Muestra el men\u00fa de comandos disponibles\n    printf(\"\\nModo 1: Control de lista\\n\");\n    printf(\"Comandos: escribir, reemplazar, borrar (terminar con ';')\\n&gt; \");\n\n    // Inicializa variables para lectura de comando\n    comando = \"\";             // Buffer para almacenar el comando\n    char c;                  // Variable para cada car\u00e1cter le\u00eddo\n\n    // Loop de lectura de caracteres\n    while (true) {\n        // Verifica si se debe salir del modo\n        if (boton_modo_presionado) return;\n\n        // Intenta leer un car\u00e1cter (timeout = 0 para no bloquear)\n        int ch = getchar_timeout_us(0);\n\n        // Si no hay caracteres disponibles, contin\u00faa el loop\n        if (ch == PICO_ERROR_TIMEOUT) continue;\n\n        // Convierte el c\u00f3digo ASCII a car\u00e1cter\n        c = (char)ch;\n\n        // Si es punto y coma, termina la lectura del comando\n        if (c == ';') break;\n\n        // Agrega el car\u00e1cter al comando en construcci\u00f3n\n        comando += c;\n    }\n\n    // === Comando BORRAR: Elimina todas las posiciones guardadas ===\n    if (comando == \"borrar\") {\n        cantidad = 0;                    // Reinicia el contador de posiciones a cero\n        printf(\"OK. Lista borrada.\\n\");  // Informa al usuario que la operaci\u00f3n fue exitosa\n        return;                         // Sale de la funci\u00f3n modo1\n    }\n\n    // === Comando ESCRIBIR: Ingresa una nueva secuencia de posiciones ===\n    if (comando == \"escribir\") {\n        // Solicita al usuario ingresar los valores con el formato correcto\n        printf(\"Ingrese valores (0\u2013180) separados por comas, termine con ';'\\n&gt; \");\n        cantidad = 0;                    // Reinicia el contador para la nueva lista\n        string valor = \"\";              // Buffer temporal para construir cada n\u00famero\n        while (true) {\n            // Verifica si se debe salir del modo\n            if (boton_modo_presionado) return;\n            // Intenta leer un car\u00e1cter de forma no bloqueante\n            int ch = getchar_timeout_us(0);\n            // Si no hay datos disponibles, contin\u00faa el loop\n            if (ch == PICO_ERROR_TIMEOUT) continue;\n            // Convierte el c\u00f3digo ASCII a car\u00e1cter\n            char c = (char)ch;\n\n            // Si encuentra separador y hay un n\u00famero acumulado\n            if ((c == ',' || c == ';') &amp;&amp; valor != \"\") {\n                // Convierte la cadena a n\u00famero\n                int num = atoi(valor.c_str());\n                // Valida que el \u00e1ngulo est\u00e9 en el rango permitido\n                if (num &lt; 0 || num &gt; 180) {\n                    printf(\"Error argumento invalido\\n\");\n                    return;\n                }\n                // Almacena el n\u00famero y aumenta el contador\n                lista[cantidad++] = num;\n                valor = \"\";              // Limpia el buffer para el siguiente n\u00famero\n                if (c == ';') break;    // Si es punto y coma, termina la entrada\n            } else if (c != ',' &amp;&amp; c != ' ') {\n                // Si no es separador ni espacio, acumula el d\u00edgito\n                valor += c;\n            }\n\n            // Termina si encuentra punto y coma (redundante pero seguro)\n            if (c == ';') break;\n        }\n\n        // Verifica que se haya ingresado al menos un valor\n        if (cantidad == 0) {\n            printf(\"Error argumento invalido\\n\");\n        } else {\n            // Muestra la lista completa ingresada\n            printf(\"OK. Lista: \");\n            for (int i = 0; i &lt; cantidad; i++) {\n                printf(\"%d\", lista[i]);\n                // Agrega coma excepto despu\u00e9s del \u00faltimo n\u00famero\n                if (i &lt; cantidad - 1) printf(\", \");\n            }\n            printf(\"\\n\");\n        }\n        return;\n    }\n\n    // === Comando REEMPLAZAR: Modifica una posici\u00f3n existente ===\n    if (comando == \"reemplazar\") {\n        // Verifica que haya posiciones para modificar\n        if (cantidad == 0) {\n            printf(\"No hay valores en la lista.\\n\");\n            return;\n        }\n\n        // Solicita el \u00edndice y nuevo valor con formato espec\u00edfico\n        printf(\"Ingrese \u00edndice y nuevo valor separados por coma, termine con ';'\\n&gt; \");\n        string valor = \"\";              // Buffer para construir los n\u00fameros\n        int datos[2];                  // Almacena [\u00edndice, nuevo_valor]\n        int n = 0;                     // Contador de n\u00fameros le\u00eddos\n\n        // Loop de lectura de caracteres\n        while (true) {\n            // Permite salir con el bot\u00f3n de modo\n            if (boton_modo_presionado) return;\n            // Lectura no bloqueante de caracteres\n            int ch = getchar_timeout_us(0);\n            if (ch == PICO_ERROR_TIMEOUT) continue;\n            char c = (char)ch;\n\n            // Procesa el n\u00famero cuando encuentra un separador\n            if ((c == ',' || c == ';') &amp;&amp; valor != \"\") {\n                datos[n++] = atoi(valor.c_str());    // Convierte y guarda el n\u00famero\n                valor = \"\";                          // Limpia buffer para siguiente n\u00famero\n                if (c == ';' || n == 2) break;      // Sale si tiene los dos valores\n            } else if (c != ',' &amp;&amp; c != ' ') {\n                // Acumula d\u00edgitos si no es separador ni espacio\n                valor += c;\n            }\n\n            // Sale si encuentra punto y coma (redundante pero seguro)\n            if (c == ';') break;\n        }\n\n        // Verifica que se ingresaron dos n\u00fameros\n        if (n &lt; 2) {\n            printf(\"Error argumento invalido\\n\");\n            return;\n        }\n\n        // Procesa los valores ingresados\n        int i = datos[0] - 1;          // Convierte \u00edndice a base 0\n        int v = datos[1];              // Nuevo valor a guardar\n\n        // Valida que el \u00edndice est\u00e9 en rango\n        if (i &lt; 0 || i &gt;= cantidad) {\n            printf(\"Error indice invalido\\n\");\n            return;\n        }\n        // Valida que el \u00e1ngulo est\u00e9 en rango\n        if (v &lt; 0 || v &gt; 180) {\n            printf(\"Error argumento invalido\\n\");\n            return;\n        }\n\n        // Actualiza la posici\u00f3n y muestra la lista completa\n        lista[i] = v;\n        printf(\"OK. Lista actualizada: \");\n        for (int j = 0; j &lt; cantidad; j++) {\n            printf(\"%d\", lista[j]);\n            // Agrega coma excepto despu\u00e9s del \u00faltimo n\u00famero\n            if (j &lt; cantidad - 1) printf(\", \");\n        }\n        printf(\"\\n\");\n        return;\n    }\n\n    // Si llegamos aqu\u00ed, el comando no coincide con ninguno de los v\u00e1lidos\n    printf(\"Comando no reconocido.\\n\");\n}\n\n\nvoid modo2() {\n    printf(\"\\nModo 2: Movimiento continuo\\n\");\n    // Verificar que haya posiciones para reproducir\n    if (cantidad == 0) {\n        printf(\"No hay valores en la lista.\\n\");\n        sleep_ms(500);\n        return;\n    }\n\n    printf(\"Moviendo continuamente seg\u00fan lista...\\n\");\n    while (!boton_modo_presionado) {           // Loop principal\n        for (int i = 0; i &lt; cantidad; i++) {   // Recorrer lista\n            mover_servo(lista[i]);             // Mover a posici\u00f3n actual\n            sleep_ms(1500);                    // Esperar entre movimientos\n            if (boton_modo_presionado) return; // Permitir salir en cualquier momento\n        }\n    }\n}\n\n\nvoid modo3() {\n    // Verificar que haya posiciones para mostrar\n    if (cantidad == 0) {\n        printf(\"No hay valores en la lista.\\n\");\n        sleep_ms(500);\n        return;\n    }\n\n    static int indice = 0;                    // Mantener posici\u00f3n entre llamadas\n    mover_servo(lista[indice]);               // Mostrar posici\u00f3n inicial\n\n    while (!boton_modo_presionado) {\n        // Procesar bot\u00f3n NEXT\n        if (boton_next_presionado) {\n            boton_next_presionado = false;    // Limpiar bandera\n            indice++;                         // Avanzar\n            if (indice &gt;= cantidad) indice = 0; // Volver al inicio si necesario\n            mover_servo(lista[indice]);       // Actualizar posici\u00f3n\n        }\n\n        // Procesar bot\u00f3n PREV\n        if (boton_prev_presionado) {\n            boton_prev_presionado = false;    // Limpiar bandera\n            indice--;                         // Retroceder\n            if (indice &lt; 0) indice = cantidad - 1; // Ir al final si necesario\n            mover_servo(lista[indice]);       // Actualizar posici\u00f3n\n        }\n\n        sleep_ms(20);                        // Breve delay para estabilidad\n    }\n}\n\n\nint main() {\n    // Inicializaci\u00f3n de comunicaci\u00f3n serial\n    stdio_init_all();                    // Habilita UART para comunicaci\u00f3n\n    sleep_ms(500);                       // Espera para estabilizaci\u00f3n del sistema\n\n    // === Configuraci\u00f3n de GPIOs para botones ===\n    // Bot\u00f3n de cambio de modo\n    gpio_init(BUTTON_MODE);              // Inicializa el pin\n    gpio_set_dir(BUTTON_MODE, GPIO_IN);  // Configura como entrada\n\n    // Bot\u00f3n para avanzar en la secuencia\n    gpio_init(BOTON_NEXT);               // Inicializa el pin\n    gpio_set_dir(BOTON_NEXT, GPIO_IN);   // Configura como entrada\n\n    // Bot\u00f3n para retroceder en la secuencia\n    gpio_init(BOTON_PREV);               // Inicializa el pin\n    gpio_set_dir(BOTON_PREV, GPIO_IN);   // Configura como entrada\n\n    // === Configuraci\u00f3n de interrupciones ===\n    // Todos los botones:\n    // - Activan en flanco de subida (presionar)\n    // - Usan la misma funci\u00f3n de callback\n    // - Tienen debouncing por software\n    gpio_set_irq_enabled_with_callback(BUTTON_MODE, GPIO_IRQ_EDGE_RISE, true, &amp;cambio_modo);\n    gpio_set_irq_enabled_with_callback(BOTON_NEXT, GPIO_IRQ_EDGE_RISE, true, &amp;cambio_modo);\n    gpio_set_irq_enabled_with_callback(BOTON_PREV, GPIO_IRQ_EDGE_RISE, true, &amp;cambio_modo);\n\n    // === Inicializaci\u00f3n del sistema ===\n    configurar_servo();                  // Configura PWM para el servo\n    printf(\"Programa iniciado. Modo 1.\\n\");  // Mensaje inicial\n\n    // === Loop principal del programa ===\n    while (true) {\n        // Manejo del cambio de modo\n        if (boton_modo_presionado) {\n            boton_modo_presionado = false;    // Limpia la bandera\n            modo++;                           // Avanza al siguiente modo\n            if (modo &gt; 3) modo = 1;           // Vuelve a modo 1 si excede\n            printf(\"\\n--- Modo cambiado a: %d ---\\n\", modo);  // Notifica cambio\n        }\n\n        // Ejecuci\u00f3n del modo actual\n        if (modo == 1) modo1();              // Modo Entrenamiento\n        else if (modo == 2) modo2();         // Modo Continuo\n        else if (modo == 3) modo3();         // Modo Paso a Paso\n\n        sleep_ms(50);\n    }\n}\n</code></pre> <p>Video</p> <p>Ver video en YouTube</p>"},{"location":"SE_1/Proyecto_Final/","title":"Proyecto Final","text":""},{"location":"SE_1/Proyecto_Final/#1-raton-resuelve-laberintos","title":"1) Rat\u00f3n resuelve laberintos","text":"<p>El proyecto Micromouse consiste en dise\u00f1ar y programar un robot m\u00f3vil aut\u00f3nomo capaz de explorar un laberinto, construir un mapa y ejecutar una carrera r\u00e1pida (fast run) desde el inicio hasta el objetivo en el centro.</p> <p>C\u00f3digo</p> <p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;math.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include \"hardware/adc.h\"\n#include \"hardware/irq.h\"\n\n#define LED_PIN 25\n\n\n// 1. DATOS LAB\n\nfloat PASOS_POR_CM = 44.5;\nfloat PASOS_GIRO_90 = 110.0;\nfloat TAMANO_CELDA_CM = 16.0;\n\n//PINES\n#define SENSOR_L_PIN 27\n#define ADC_CH_L 1      \n#define SENSOR_F_PIN 26\n#define ADC_CH_F 0      \n#define SENSOR_R_PIN 28\n#define ADC_CH_R 2\n\n#define AIN1 12\n#define AIN2 11\n#define PWMA 10\n#define BIN1 14\n#define BIN2 13\n#define PWMB 15\n#define ENC_L_C1 20\n#define ENC_R_C1 4\n\n#define ANCHO_LABERINTO 12  \n#define MAX_DIST 255        \n\n//VARIABLES GLOBALES\nint x_actual = 0;\nint y_actual = 0; // Empezamos en la esquina (0,0)\nint orientacion = 0; // 0:Norte, 1:Este, 2:Sur, 3:Oeste\n\n// Mapas\nint mapa_distancias[ANCHO_LABERINTO][ANCHO_LABERINTO];\nint paredes_norte[ANCHO_LABERINTO][ANCHO_LABERINTO];\nint paredes_este[ANCHO_LABERINTO][ANCHO_LABERINTO];\nint celdas_visitadas[ANCHO_LABERINTO][ANCHO_LABERINTO];\n\n// Variables Motor/PID\nvolatile long steps_left = 0;\nvolatile long steps_right = 0;\nfloat Kp = 2, Kd = 5.0, error_anterior = 0;\nint velocidad_base = 15;\nconst float CONVERSION_FACTOR = 3.3f / (1 &lt;&lt; 12);\n\n//HARDWARE\nvoid init_sensors() { adc_init(); adc_gpio_init(SENSOR_L_PIN); adc_gpio_init(SENSOR_F_PIN); adc_gpio_init(SENSOR_R_PIN); }\n\n\nfloat get_distance_cm(int adc_channel) {\n    adc_select_input(adc_channel);\n\n    float suma_voltaje = 0;\n    int muestras = 5; // Promedio para el sensor\n\n    for(int i=0; i&lt;muestras; i++) {\n        uint16_t raw_value = adc_read();\n        suma_voltaje += raw_value * CONVERSION_FACTOR;\n        sleep_us(200);\n    }\n\n    float voltaje_promedio = suma_voltaje / muestras;\n\n    // Transformaci\u00f3n voltaje -&gt; distancia (cm)\n    float distance = 60.6f - (25.4f * voltaje_promedio);\n\n    // Rango del sensor\n    if (distance &lt; 0) distance = 50.0;\n    if (distance &gt; 50.0) distance = 50.0;\n\n    return distance;\n}\n\nvoid gpio_callback(uint gpio, uint32_t events) { if(gpio==ENC_L_C1) steps_left++; else steps_right++; }\n\nvoid init_motors() {\n    gpio_init(AIN1); gpio_set_dir(AIN1, GPIO_OUT); gpio_init(AIN2); gpio_set_dir(AIN2, GPIO_OUT);\n    gpio_init(BIN1); gpio_set_dir(BIN1, GPIO_OUT); gpio_init(BIN2); gpio_set_dir(BIN2, GPIO_OUT);\n    gpio_set_function(PWMA, GPIO_FUNC_PWM); gpio_set_function(PWMB, GPIO_FUNC_PWM);\n    pwm_set_wrap(pwm_gpio_to_slice_num(PWMA), 12500); pwm_set_enabled(pwm_gpio_to_slice_num(PWMA), true);\n    pwm_set_wrap(pwm_gpio_to_slice_num(PWMB), 12500); pwm_set_enabled(pwm_gpio_to_slice_num(PWMB), true);\n    gpio_init(ENC_L_C1); gpio_set_dir(ENC_L_C1, GPIO_IN); gpio_pull_up(ENC_L_C1);\n    gpio_init(ENC_R_C1); gpio_set_dir(ENC_R_C1, GPIO_IN); gpio_pull_up(ENC_R_C1);\n    gpio_set_irq_enabled_with_callback(ENC_L_C1, GPIO_IRQ_EDGE_RISE, true, &amp;gpio_callback);\n    gpio_set_irq_enabled(ENC_R_C1, GPIO_IRQ_EDGE_RISE, true);\n}\n\nvoid set_speed_pwm(uint pin, int s) { if(s&gt;100)s=100; if(s&lt;0)s=0; pwm_set_chan_level(pwm_gpio_to_slice_num(pin), pwm_gpio_to_channel(pin), (s*12500)/100); }\n\nvoid motor_control(int l, int r) {\n    if(l&gt;=0){gpio_put(AIN1,0);gpio_put(AIN2,1);set_speed_pwm(PWMA,l);}else{gpio_put(AIN1,1);gpio_put(AIN2,0);set_speed_pwm(PWMA,abs(l));}\n    if(r&gt;=0){gpio_put(BIN1,0);gpio_put(BIN2,1);set_speed_pwm(PWMB,r);}else{gpio_put(BIN1,1);gpio_put(BIN2,0);set_speed_pwm(PWMB,abs(r));}\n}\n\nvoid parar(){motor_control(0,0); sleep_ms(200);}\nvoid reset_encoders(){steps_left=0; steps_right=0;}\n\n//Movimientos\n\nvoid alinear_con_frente() {\n    float dF = get_distance_cm(ADC_CH_F);\n    float DISTANCIA_CENTRO_PARED = 4.0;\n\n    // Si estamos muy lejos, no intentamos alinear\n    if (dF &gt; 15.0) return;\n\n    // tiempo para corregir\n    unsigned long tiempo_inicio = to_ms_since_boot(get_absolute_time());\n\n    while (true) {\n        dF = get_distance_cm(ADC_CH_F);\n        float error = dF - DISTANCIA_CENTRO_PARED;\n\n        // Si el error es muy peque\u00f1o no hace nada\n        if (fabs(error) &lt; 0.3) break;\n\n        // tiempo para corregir\n        if (to_ms_since_boot(get_absolute_time()) - tiempo_inicio &gt; 1000) break;\n\n        // Velocidad de correcion\n        int velocidad_ajuste = 25;\n\n        if (error &gt; 0) {\n            // Si el error es mayor a 0 se acerca\n            motor_control(velocidad_ajuste, velocidad_ajuste);\n        } else {\n            // Se aleja por el error negativo\n            motor_control(-velocidad_ajuste, -velocidad_ajuste);\n        }\n        sleep_ms(10);\n    }\n    parar();\n\n    //resetear encoders\n    reset_encoders();\n}\n\nvoid avanzar_celda() {\n    reset_encoders();\n\n    // Corregir cuando va demasiado r\u00e1pido y que no se derrape\n    float descuento_inercia = 0;\n    if (velocidad_base &gt; 30) {\n        descuento_inercia = 1;\n    }\n\n    long pasos_meta = (long)(PASOS_POR_CM * (TAMANO_CELDA_CM - descuento_inercia));\n\n    // Configuraci\u00f3n PID\n    float DISTANCIA_IDEAL = 6;\n    float UMBRAL_PARED = 10.0;\n    float Kp_Enc = 1.5; float Kd_Enc = 5.0; float prev_diff_pasos = 0;\n\n    while (true) {\n        long pasos = (steps_left + steps_right) / 2;\n\n        //Condicion para parar al cumplir los 16 cm\n        if (pasos &gt;= pasos_meta) {\n            parar();\n            break;\n        }\n\n\n        // checar la distancia del sensor\n        float dF = get_distance_cm(ADC_CH_F);\n\n        // si vamos rapido usamos 4.5, si vamos lento usamos 3.5\n        float distancia_freno_sensor = (velocidad_base &gt; 30) ? 4.5 : 3.5;\n\n        if (dF &lt; distancia_freno_sensor) {\n            parar();\n            // lo anterior pero aplicado\n            if (velocidad_base &gt; 30) alinear_con_frente();\n            break;\n        }\n\n        // distancia de los sensores laterales\n        float dL = get_distance_cm(ADC_CH_L);\n        float dR = get_distance_cm(ADC_CH_R);\n        float err = 0;\n        bool usar_pid_paredes = true;\n\n\n        if (dL &lt; UMBRAL_PARED &amp;&amp; dR &lt; UMBRAL_PARED) { err = dL - dR; }//Caso donde tiene las dos paredes\n        else if (dL &lt; UMBRAL_PARED) { err = (dL - DISTANCIA_IDEAL); }  //Caso donde solo tiene pared izquierda\n        else if (dR &lt; UMBRAL_PARED) { err = (DISTANCIA_IDEAL - dR); } //Caso donde solo tiene pared derecha\n        else {\n            usar_pid_paredes = false;\n            long diff_pasos = steps_left - steps_right;\n            float P = diff_pasos * Kp_Enc;\n            float D = (diff_pasos - prev_diff_pasos) * Kd_Enc;\n            float correccion_enc = P + D;\n            prev_diff_pasos = diff_pasos;\n            motor_control(velocidad_base - (int)correccion_enc, velocidad_base + (int)correccion_enc);\n        } //Caso cuando no hay paredes y se utilizan los encoders para ir derecho\n\n        if (abs(err) &lt; 0.5) err = 0;\n\n        if (usar_pid_paredes) {\n            prev_diff_pasos = 0;\n            float correccion = (err * Kp) + ((err - error_anterior) * Kd);\n            error_anterior = err;\n            motor_control(velocidad_base - correccion, velocidad_base + correccion);\n        }\n        sleep_ms(10);\n    }\n}\n\nvoid retroceder_celda() {\n    reset_encoders();\n    long pasos_meta = (long)(PASOS_POR_CM * TAMANO_CELDA_CM);\n\n    float Kp_recto = 1.5; // ir derecho cuando va hacia atras\n\n    int vel_back = 15;\n\n    while (true) {\n        // es como el set point\n        long pasos = (steps_left + steps_right) / 2;\n\n        // para ir de 16 en 16\n        if (pasos &gt;= pasos_meta) { parar(); break; }\n\n        // calcular el error de pasos con los encoders\n        long error_pasos = steps_left - steps_right;\n\n        // calcular la correcion\n        int correccion = (int)(error_pasos * Kp_recto);\n\n        int motor_L = -vel_back + correccion; // Negativo para ir hacia atras\n        int motor_R = -vel_back - correccion; // Negativo para ir hacia atras para que se vaya detras\n\n        motor_control(motor_L, motor_R);\n        sleep_ms(10);\n    }\n    parar();\n    sleep_ms(100);\n}\n\nvoid girar_90(int direccion) { // 1=Der -1=Izq Para girar\n    parar(); reset_encoders();\n    long pasos_meta = (long)PASOS_GIRO_90;\n    int vel = 30;\n    while((steps_left+steps_right)/2 &lt; pasos_meta) {\n        if(direccion&gt;0) motor_control(vel, -vel);\n        else motor_control(-vel, vel);\n        sleep_ms(10);\n    }\n    parar();\n}\n\n// Logica poara el Fload Fill\nvoid init_laberinto() {\n    for(int y=0; y&lt;ANCHO_LABERINTO; y++) {\n        for(int x=0; x&lt;ANCHO_LABERINTO; x++) {\n            paredes_norte[y][x] = 0; //Para el origen 0, 0\n            paredes_este[y][x] = 0;\n            if(y == ANCHO_LABERINTO-1) paredes_norte[y][x] = 1;\n            if(x == ANCHO_LABERINTO-1) paredes_este[y][x] = 1;  \n        }\n    }\n}\n\n// Para cuando se pone en modo rapido\nvoid flood_fill(bool modo_estricto) {\n    // Inicializaci\u00f3n del mapa de distancias\n    for(int y=0; y&lt;ANCHO_LABERINTO; y++)\n        for(int x=0; x&lt;ANCHO_LABERINTO; x++)\n            mapa_distancias[y][x] = MAX_DIST;\n\n    // Centro del laberinto\n    mapa_distancias[5][5] = 0;\n    mapa_distancias[5][6] = 0;\n    mapa_distancias[6][5] = 0;\n    mapa_distancias[6][6] = 0;\n\n    // Para ir cambiando los valores de la matriz que en la meta es 0, 0 y a los lados va cambiando\n    int cambios = 1;\n    while(cambios &gt; 0) {\n        cambios = 0;\n        for(int y=0; y&lt;ANCHO_LABERINTO; y++) {\n            for(int x=0; x&lt;ANCHO_LABERINTO; x++) {\n\n                // Cuando mapeas y no visitas esas celdas, lo que se hace cuando el raton esta en modo rapido se pone una pared\n                if (modo_estricto &amp;&amp; celdas_visitadas[y][x] == 0) {\n                    bool es_meta = (x==5||x==6) &amp;&amp; (y==5||y==6);\n                    if (!es_meta) continue;\n                }\n\n                if(mapa_distancias[y][x] == MAX_DIST) continue;\n\n                int dist_vecino = mapa_distancias[y][x] + 1;\n\n                // IR GENERANDO LAS PAREDES\n                if (y &lt; ANCHO_LABERINTO-1 &amp;&amp; !paredes_norte[y][x]) {\n\n                    if (!modo_estricto || celdas_visitadas[y+1][x]) {\n                        if (mapa_distancias[y+1][x] &gt; dist_vecino) {\n                            mapa_distancias[y+1][x] = dist_vecino; cambios++;\n                        }\n                    }\n                }\n                // PARA IR GENERANDO LAS PAREDES\n                if (x &lt; ANCHO_LABERINTO-1 &amp;&amp; !paredes_este[y][x]) {\n                    if (!modo_estricto || celdas_visitadas[y][x+1]) {\n                        if (mapa_distancias[y][x+1] &gt; dist_vecino) {\n                            mapa_distancias[y][x+1] = dist_vecino; cambios++;\n                        }\n                    }\n                }\n                if (y &gt; 0 &amp;&amp; !paredes_norte[y-1][x]) {\n                    if (!modo_estricto || celdas_visitadas[y-1][x]) {\n                        if (mapa_distancias[y-1][x] &gt; dist_vecino) {\n                            mapa_distancias[y-1][x] = dist_vecino; cambios++;\n                        }\n                    }\n                }\n                //PARA IR GENERANDO LAS PAREDES\n                if (x &gt; 0 &amp;&amp; !paredes_este[y][x-1]) {\n                    if (!modo_estricto || celdas_visitadas[y][x-1]) {\n                        if (mapa_distancias[y][x-1] &gt; dist_vecino) {\n                            mapa_distancias[y][x-1] = dist_vecino; cambios++;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid detectar_paredes() {  // Leer sensores\n    float dF = get_distance_cm(ADC_CH_F);\n    float dL = get_distance_cm(ADC_CH_L);\n    float dR = get_distance_cm(ADC_CH_R);\n\n    // SI LA DISTANCIA ES MENOR A 12 ES 1, DE LO CONTRARIO 0\n    int pared_frente = (dF &lt; 12.0) ? 1 : 0;\n    int pared_izq    = (dL &lt; 12.0) ? 1 : 0;\n    int pared_der    = (dR &lt; 12.0) ? 1 : 0;\n\n    // PARA IR GUARDANDO LAS PAREDES\n\n    if (pared_frente) {\n        if(orientacion==0 &amp;&amp; y_actual&lt;ANCHO_LABERINTO-1) paredes_norte[y_actual][x_actual] = 1;\n        if(orientacion==1 &amp;&amp; x_actual&lt;ANCHO_LABERINTO-1) paredes_este[y_actual][x_actual]  = 1;\n        if(orientacion==2 &amp;&amp; y_actual&gt;0)                 paredes_norte[y_actual-1][x_actual] = 1;\n        if(orientacion==3 &amp;&amp; x_actual&gt;0)                 paredes_este[y_actual][x_actual-1]  = 1;\n    }\n\n    if (pared_der) {\n        int od = (orientacion+1)%4;\n        if(od==0 &amp;&amp; y_actual&lt;ANCHO_LABERINTO-1) paredes_norte[y_actual][x_actual] = 1;\n        if(od==1 &amp;&amp; x_actual&lt;ANCHO_LABERINTO-1) paredes_este[y_actual][x_actual]  = 1;\n        if(od==2 &amp;&amp; y_actual&gt;0)                 paredes_norte[y_actual-1][x_actual] = 1;\n        if(od==3 &amp;&amp; x_actual&gt;0)                 paredes_este[y_actual][x_actual-1]  = 1;\n    }\n\n    if (pared_izq) {\n        int oi = (orientacion+3)%4;\n        if(oi==0 &amp;&amp; y_actual&lt;ANCHO_LABERINTO-1) paredes_norte[y_actual][x_actual] = 1;\n        if(oi==1 &amp;&amp; x_actual&lt;ANCHO_LABERINTO-1) paredes_este[y_actual][x_actual]  = 1;\n        if(oi==2 &amp;&amp; y_actual&gt;0)                 paredes_norte[y_actual-1][x_actual] = 1;\n        if(oi==3 &amp;&amp; x_actual&gt;0)                 paredes_este[y_actual][x_actual-1]  = 1;\n    }\n}\n\nvoid ejecutar_speed_run() {\n\n\n    for(int i=0; i&lt;20; i++) {\n        gpio_put(LED_PIN, 1); sleep_ms(100);\n        gpio_put(LED_PIN, 0); sleep_ms(900);\n    }\n\n    for(int i=0; i&lt;10; i++) { gpio_put(LED_PIN, 1); sleep_ms(50); gpio_put(LED_PIN, 0); sleep_ms(50); }\n\n    // VOLVER A PONER EL RATON EN EL ORIGEN\n    x_actual = 0;\n    y_actual = 0;\n    orientacion = 0;\n\n    //VELOCIDAD CUANDO VA RAPIDO\n    velocidad_base = 50;\n    flood_fill(true); // que haga el camino que ya se guardo\n\n    // checar si la ruta esta bien guardada\n    if (mapa_distancias[0][0] &gt;= 255) {\n        init_laberinto();\n        flood_fill(false);\n    }\n\n    // ir moviendose\n    while(true) {\n        if(mapa_distancias[y_actual][x_actual] == 0) {\n            parar();\n            while(true) { gpio_put(LED_PIN, 1); sleep_ms(100); gpio_put(LED_PIN, 0); sleep_ms(100); }\n        }\n\n        float dF = get_distance_cm(ADC_CH_F);\n\n        if (dF &lt; 12.0) {\n            alinear_con_frente();            \n        }\n\n        int d_actual = mapa_distancias[y_actual][x_actual];\n        int mejor_orientacion = -1;\n        int menor_distancia = d_actual;\n\n        if(y_actual&lt;ANCHO_LABERINTO-1 &amp;&amp; !paredes_norte[y_actual][x_actual])\n            if(mapa_distancias[y_actual+1][x_actual] &lt; menor_distancia) {\n                menor_distancia = mapa_distancias[y_actual+1][x_actual]; mejor_orientacion = 0;\n            }\n        if(x_actual&lt;ANCHO_LABERINTO-1 &amp;&amp; !paredes_este[y_actual][x_actual])\n            if(mapa_distancias[y_actual][x_actual+1] &lt; menor_distancia) {\n                menor_distancia = mapa_distancias[y_actual][x_actual+1]; mejor_orientacion = 1;\n            }\n\n        if(y_actual&gt;0 &amp;&amp; !paredes_norte[y_actual-1][x_actual])\n            if(mapa_distancias[y_actual-1][x_actual] &lt; menor_distancia) {\n                menor_distancia = mapa_distancias[y_actual-1][x_actual]; mejor_orientacion = 2;\n            }\n\n        if(x_actual&gt;0 &amp;&amp; !paredes_este[y_actual][x_actual-1])\n            if(mapa_distancias[y_actual][x_actual-1] &lt; menor_distancia) {\n                menor_distancia = mapa_distancias[y_actual][x_actual-1]; mejor_orientacion = 3;\n            }\n\n        if(mejor_orientacion == -1) {\n            parar();  \n            break;\n        }\n\n        // girar\n        int diff = mejor_orientacion - orientacion;\n        if(diff == 1 || diff == -3) { girar_90(1); orientacion = (orientacion + 1) % 4; }\n        else if(diff == -1 || diff == 3) { girar_90(-1); orientacion = (orientacion + 3) % 4; }\n\n        avanzar_celda();\n\n        //ir cambiando las coordenadas\n        if(orientacion == 0) y_actual++;\n        else if(orientacion == 1) x_actual++;\n        else if(orientacion == 2) y_actual--;\n        else if(orientacion == 3) x_actual--;\n\n        sleep_ms(20);\n    }\n}\n\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    init_sensors();\n    init_motors();\n    init_laberinto();\n\n  celdas_visitadas[0][0] = 1;\n\n    sleep_ms(5000);\n\n\nwhile(true) {\n\n        //META\n          if( (x_actual == 5 || x_actual == 6) &amp;&amp; (y_actual == 5 || y_actual == 6) ) {\n            parar();\n\n            for(int i=0; i&lt;5; i++) { gpio_put(LED_PIN,1); sleep_ms(100); gpio_put(LED_PIN,0); sleep_ms(100); }\n\n            //PARA EJECUTAR EL SPEED RUN\n            ejecutar_speed_run();\n            break;\n        }\n\n        celdas_visitadas[y_actual][x_actual] = 1;\n\n        detectar_paredes();\n        // Detectar si hay una pared justo enfrente y alinear\n        if (paredes_norte[y_actual][x_actual] &amp;&amp; orientacion == 0) alinear_con_frente();\n        if (paredes_este[y_actual][x_actual]  &amp;&amp; orientacion == 1) alinear_con_frente();\n        if (paredes_norte[y_actual-1][x_actual] &amp;&amp; orientacion == 2) alinear_con_frente(); // Pared sur (norte del vecino)\n        if (paredes_este[y_actual][x_actual-1]  &amp;&amp; orientacion == 3) alinear_con_frente(); // Pared oeste\n\n        flood_fill(false);\n\n        //checa los sensores laterales para ver la mejor direccion hacia cual girar\n        int min_dist = MAX_DIST;\n        int mejor_orientacion = -1;\n\n        // Checra las cuatro direcciones\n        if(y_actual&lt;ANCHO_LABERINTO-1 &amp;&amp; !paredes_norte[y_actual][x_actual])\n            if(mapa_distancias[y_actual+1][x_actual] &lt; min_dist) { min_dist=mapa_distancias[y_actual+1][x_actual]; mejor_orientacion=0; }\n\n        if(x_actual&lt;ANCHO_LABERINTO-1 &amp;&amp; !paredes_este[y_actual][x_actual])\n            if(mapa_distancias[y_actual][x_actual+1] &lt; min_dist) { min_dist=mapa_distancias[y_actual][x_actual+1]; mejor_orientacion=1; }\n\n        if(y_actual&gt;0 &amp;&amp; !paredes_norte[y_actual-1][x_actual])\n            if(mapa_distancias[y_actual-1][x_actual] &lt; min_dist) { min_dist=mapa_distancias[y_actual-1][x_actual]; mejor_orientacion=2; }\n\n        if(x_actual&gt;0 &amp;&amp; !paredes_este[y_actual][x_actual-1])\n            if(mapa_distancias[y_actual][x_actual-1] &lt; min_dist) { min_dist=mapa_distancias[y_actual][x_actual-1]; mejor_orientacion=3; }\n\n\n\n        // Para cuando esta bloqueado en las 3 paredes\n        if(mejor_orientacion == -1) {\n             retroceder_celda();\n             // Actualizar corrdenadas\n             if(orientacion == 0) y_actual--;\n             else if(orientacion == 1) x_actual--;\n             else if(orientacion == 2) y_actual++;\n             else if(orientacion == 3) x_actual++;\n             continue;\n        }\n\n        // Para verificar el giro necesario\n        int diff = mejor_orientacion - orientacion;\n\n        // Donde esta encerrado por 2 paredes y debe ir hacia atras\n        if(abs(diff) == 2) {\n             retroceder_celda();\n             // Actualizar coordenadas hacia atr\u00e1s\n             if(orientacion == 0) y_actual--;\n             else if(orientacion == 1) x_actual--;\n             else if(orientacion == 2) y_actual++;\n             else if(orientacion == 3) x_actual++;\n             continue;\n        }\n\n        // Giros izquierda o derecha\n        if(diff == 1 || diff == -3) {\n            girar_90(1);\n            orientacion = (orientacion + 1) % 4;\n        } else if(diff == -1 || diff == 3) {\n            girar_90(-1);\n            orientacion = (orientacion + 3) % 4;\n        }\n\n        // Avanzar si hay camino al fernye\n        avanzar_celda();\n\n        // Actualizar coordenadas\n        if(orientacion == 0) y_actual++;\n        else if(orientacion == 1) x_actual++;\n        else if(orientacion == 2) y_actual--;\n        else if(orientacion == 3) x_actual--;\n\n        sleep_ms(150);\n    }\n    return 0;\n}\n</code></pre> Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p>"},{"location":"SE_1/Tarea1/","title":"Tarea 1","text":"<p>Investiga al menos 4 microcontroladores de distintas marcas y haz una tabla comparativa de: - Perif\u00e9ricos - Memoria - Ecosistema - Costos - Arquitectura - Velocidad de trabajo</p>"},{"location":"SE_1/Tarea1/#1-proyecto","title":"1) Proyecto","text":"<p>L\u00e1mpara que se iluminan al ritmo de tu coraz\u00f3n. </p>"},{"location":"SE_1/Tarea1/#2-tabla","title":"2) Tabla","text":"Microcontrolador Perif\u00e9ricos Memoria Ecosistema Costos Arquitectura Velocidad de trabajo Raspberry Pi Pico ADC, SPI, I2C, PWM, USB 1.1, 30 GPIO programables 264 KB RAM, hasta 16 MB Flash externa MicroPython, SDK en C $90\u2013130 MX ARM Cortex-M0+ 32 bits, doble n\u00facleo 133 MHz ESP32 T\u00e1ctiles capacitivos, Hall, LNAs, SD, Ethernet, SPI, UART, I2S, I2C 520 KB RAM interna Arduino IDE, ESP-IDF, MicroPython, IoT $80\u2013180 MX Harvard, 32 bits 240 MHz Arduino Nano UART, SPI, I\u00b2C, ADC (10 bits), PWM 2 KB SRAM, 32 KB Flash, 1 KB EEPROM Arduino IDE, bibliotecas abundantes $370\u2013460 MX AVR ATmega328P, 8 bits 16 MHz ATTiny85 UART, I\u00b2C, SPI, ADC, PWM 512 B SRAM, 8 KB Flash, 512 B EEPROM Arduino IDE $20\u201350 MX AVR 8 bits 8\u201320 MHz"},{"location":"SE_1/Tarea1/#3-ranking-de-eleccion","title":"3) Ranking de elecci\u00f3n","text":"<ol> <li> <p>ESP32: Tiene buena memoria y velocidad, ademas de que cuenta con conexi\u00f3n WiFi/Bluetooth lo que a futuro podr\u00eda facilitar el desarrollo de una aplicaci\u00f3n. </p> </li> <li> <p>Raspberry Pi Pico: Cuenta con buena memoria pero por el tema de las futuras mejoras lo coloco en segundo lugar.</p> </li> <li> <p>Arduino Nano: Es f\u00e1cil de programar pero tambien tiene poca memoria y velocidad. </p> </li> <li> <p>ATTiny85: Es el microcontrolador m\u00e1s econ\u00f3mico pero tiene poca memoria, no podr\u00eda controlar animaciones complejas en la l\u00e1mpara. </p> </li> </ol>"},{"location":"SE_1/Tarea2/","title":"Tarea 2","text":"<p>Documenta en tu pagina los siguientes codigos usando logica y mascaras no se pueden poner todas las combinaciones:</p>"},{"location":"SE_1/Tarea2/#1-contador-binario-4-bits","title":"1) Contador binario 4 bits","text":"<p>En cuatro leds debe mostrarse cad segundo la representacion binaria del 0 al 15.</p> <p>C\u00f3digo</p> <p><pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n#define PIN_A 2\n#define PIN_B 4\n#define PIN_C 5\n#define PIN_D 6\n\nint main() {\n    // 1) M\u00e1scara con varios pines\n    const uint32_t MASK = (1u&lt;&lt;0) | (1u&lt;&lt;1) | (1u&lt;&lt;2)| (1u&lt;&lt;3);\n\n    // 2) Asegura funci\u00f3n SIO en cada pin (necesario una sola vez)\n    gpio_init(0);\n    gpio_init(1);\n    gpio_init(2);\n    gpio_init(3);\n    // 3) Direcci\u00f3n: salida (OE=1) para TODOS los pines con UNA sola instrucci\u00f3n\n    gpio_set_dir_out_masked(MASK);\n    uint8_t contador=0;\n\n    while (true) {\n\n        gpio_put_masked(MASK, contador);\n        sleep_ms(500);\n\n        contador++;\n\n        if (contador&gt;=16){\n            contador=0;\n        }\n}\n}\n</code></pre> Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p> <p>Ver video en YouTube</p>"},{"location":"SE_1/Tarea2/#2-barrido-de-leds","title":"2) Barrido de leds","text":"<p>Correr un \u201c1\u201d por cinco LEDs P0..P3 y regresar (0\u21921\u21922\u21923\u21922\u21921\u2026)</p> <p>C\u00f3digo</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\n#define PIN_A 2\n#define PIN_B 4\n#define PIN_C 5\n#define PIN_D 6\n\nint main() {\n    // 1) M\u00e1scara con varios pines\n    const uint32_t MASK = (1u&lt;&lt;0) | (1u&lt;&lt;1) | (1u&lt;&lt;2)| (1u&lt;&lt;3);\n\n    // 2) Asegura funci\u00f3n SIO en cada pin (necesario una sola vez)\n    gpio_init(0);\n    gpio_init(1);\n    gpio_init(2);\n    gpio_init(3);\n    // 3) Direcci\u00f3n: salida (OE=1) para TODOS los pines con UNA sola instrucci\u00f3n\n    gpio_set_dir_out_masked(MASK);\n\n    int pos=0;\n    int mov=1;\n\n    while (true) {\n\n        gpio_put_masked(MASK, 1&lt;&lt;pos);\n            // alto en 2,4,6\n        sleep_ms(500);\n\n        pos=pos+mov;\n\n        if (pos==3){\n            mov=-1;\n        }\n\n        else if (pos==0){\n            mov=1;\n        }\n}\n}\n</code></pre> <p>Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p> <p>Ver video en YouTube</p>"},{"location":"SE_1/Tarea2/#3-secuencia-en-codigo-gray","title":"3) Secuencia en codigo Gray","text":"<p>C\u00f3digo</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\n#define PIN_A 0\n#define PIN_B 1\n#define PIN_C 2\n#define PIN_D 3\n\nint main() {\n\n    // 2) Asegura funci\u00f3n SIO en cada pin (necesario una sola vez)\n    gpio_init(0);\n    gpio_init(1);\n    gpio_init(2);\n    gpio_init(3);\n    // 3) Direcci\u00f3n: salida (OE=1) para TODOS los pines con UNA sola instrucci\u00f3n\n\n    uint32_t cont=0;\n\n\n    sio_hw-&gt;gpio_oe_set = (1 &lt;&lt; PIN_A);\n    sio_hw-&gt;gpio_oe_set = (1 &lt;&lt; PIN_B);\n    sio_hw-&gt;gpio_oe_set = (1 &lt;&lt; PIN_C);\n    sio_hw-&gt;gpio_oe_set = (1 &lt;&lt; PIN_D);\n\n    while (true) {\n\n        uint32_t sec = cont ^ (cont &gt;&gt; 1);\n\n        if (sec&amp;0x1){\n            gpio_put(PIN_A,1);\n        }\n\n        else{\n            gpio_put(PIN_A,0);\n        }\n\n        if (sec&amp;0x2){\n            gpio_put(PIN_B,1);\n        }\n\n        else {\n            gpio_put(PIN_B,0);\n        }\n\n        if (sec&amp;0x4){\n            gpio_put(PIN_C,1);  \n        }\n\n        else{\n            gpio_put(PIN_C,0);\n        }\n\n        if (sec&amp;0x8){\n            gpio_put(PIN_D,1);      \n        }\n\n        else{\n            gpio_put(PIN_D,0);\n        }\n        cont++;\n        sleep_ms(500);\n\n}\n}\n</code></pre> <p>Esquematico de conexi\u00f3n </p> <p>Video</p> <p>Ver video en YouTube</p>"},{"location":"SE_1/Tarea3/","title":"Tarea 3","text":"<p>Documenta en tu p\u00e1gina los siguientes c\u00f3digos usando l\u00f3gica y m\u00e1scaras</p>"},{"location":"SE_1/Tarea3/#1-compuertas-basicas-and-or-xor-con-2-botones","title":"1) Compuertas b\u00e1sicas AND / OR / XOR con 2 botones","text":"<p>Con dos botones A y B (pull-up; presionado=0) enciende tres LEDs que muestren en paralelo los resultados de AND, OR y XOR. En el video muestra las 4 combinaciones (00, 01, 10, 11).</p> <p>C\u00f3digo</p> <p><pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\n#define Boton_1 16\n#define Boton_2 17\n#define LED_1 0\n#define LED_2 1\n#define LED_3 2\n\nint main() {\n\n    gpio_init(Boton_1);\n    gpio_set_dir(Boton_1, false);\n\n    gpio_init(Boton_2);\n    gpio_set_dir(Boton_2, false);\n\n    gpio_init(LED_1);\n    gpio_set_dir(LED_1, true);\n\n    gpio_init(LED_2);\n    gpio_set_dir(LED_2, true);\n\n    gpio_init(LED_3);\n    gpio_set_dir(LED_3, true);\n\n    while (true) {\n        bool b1 = gpio_get(Boton_1);\n        bool b2 = gpio_get(Boton_2);\n\n        if (!b1 &amp;&amp; !b2) {\n            gpio_put(LED_1, 1);\n        } else {\n            gpio_put(LED_1, 0);\n        }\n\n        if (!b1 || !b2) {\n            gpio_put(LED_2, 1);\n        } else {\n            gpio_put(LED_2, 0);\n        }\n\n        if ((b1 &amp;&amp; !b2) || (!b1 &amp;&amp; b2)) {\n            gpio_put(LED_3, 1);\n        } else {\n            gpio_put(LED_3, 0);\n        }\n\n        sleep_ms(10);\u00a0\n\u00a0\u00a0\u00a0\u00a0}\n}\n</code></pre> Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p>"},{"location":"SE_1/Tarea3/#2-selector-ciclico-de-4-leds-con-avanceretroceso","title":"2) Selector c\u00edclico de 4 LEDs con avance/retroceso","text":"<p>Mant\u00e9n un \u00fanico LED encendido entre LED0..LED3. Un bot\u00f3n AVANZA (0\u21921\u21922\u21923\u21920) y otro RETROCEDE (0\u21923\u21922\u21921\u21920). Un push = un paso (antirrebote por flanco: si dejas presionado no repite). En el video demuestra en ambos sentidos.</p> <p>C\u00f3digo</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n\nint main(void) {\n    const uint LED1 = 0;\n    const uint LED2 = 1; \n    const uint LED3 = 2;\n    const uint LED4 = 3;       \n    const uint BTN1 = 16;\n    const uint BTN2 = 17; \n\n    const uint32_t MASK = (1u&lt;&lt;LED1) | (1u&lt;&lt;LED2) | (1u&lt;&lt;LED3) | (1u&lt;&lt;LED4);\n\n    gpio_init_mask(MASK);\n    gpio_set_dir_masked(MASK, MASK);  \n    gpio_put_masked(MASK, 1u&lt;&lt;LED1); \n\n    gpio_init(BTN1);\n    gpio_set_dir(BTN1,0);\n    gpio_pull_up(BTN1);   \n    gpio_init(BTN2);\n    gpio_set_dir(BTN2,0);\n    gpio_pull_up(BTN2); \n\n    int pos=LED1;\n    int preb1 = 1;\n    int preb2 = 1;\n\n    while (true) {\n\n        if (gpio_get(BTN1)==0 &amp;&amp; preb1 == 1){\n            if(pos==LED4) pos=LED1;\n            else \n            pos++;\n            gpio_put_masked(MASK, (1u&lt;&lt;pos));\n        }\n\n        if (gpio_get(BTN2)==0 &amp;&amp; preb2 == 1){\n\n            if (pos==LED1)pos=LED4;\n            else \n            pos--;\n            gpio_put_masked(MASK, (1u&lt;&lt;pos));\n        }\n\n        preb1 = gpio_get(BTN1);\n        preb2 = gpio_get(BTN2);\n\n        sleep_ms\u00a0(200);\n\n\u00a0\u00a0\u00a0\u00a0}\n}\n</code></pre> <p>Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p>"},{"location":"SE_1/Tarea4/","title":"Tarea 4","text":"<p>Programar un mini-Pong con 5 LEDs en l\u00ednea y 2 botones usando interrupciones (ISR) para registrar el \u201cgolpe\u201d del jugador exactamente cuando la \u201cpelota\u201d (un LED encendido) llega al extremo de su lado.</p>"},{"location":"SE_1/Tarea4/#1-ping-pong","title":"1) Ping pong","text":""},{"location":"SE_1/Tarea4/#reglas-del-juego","title":"Reglas del juego","text":"<ol> <li> <p>Pelota    Es un \u00fanico LED encendido que se mueve autom\u00e1ticamente de un extremo al otro: <code>L1 \u2192 L5 \u2192 L1\u2026</code> a un ritmo fijo.</p> </li> <li> <p>Golpe con ISR    Cada bot\u00f3n genera una interrupci\u00f3n:</p> </li> <li>BTN_L: solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L1.  </li> <li>BTN_R: solo cuenta si, en el instante de la ISR, la pelota est\u00e1 en L5.  </li> <li>Coincidencia: si el bot\u00f3n coincide con la posici\u00f3n correcta de la pelota, la pelota rebota (invierte su direcci\u00f3n).  </li> <li> <p>No coincidencia: si la pelota no est\u00e1 en el \u00faltimo LED del lado presionado, el bot\u00f3n se ignora.</p> </li> <li> <p>Fallo y punto </p> </li> <li>Si la pelota alcanza L1 y no hubo golpe v\u00e1lido del lado izquierdo, anota el jugador derecho.  </li> <li> <p>Si alcanza L5 sin golpe v\u00e1lido del lado derecho, anota el jugador izquierdo.</p> </li> <li> <p>Indicador de punto    Al anotar, se parpadea el LED de punto 3 veces del jugador que meti\u00f3 el punto.</p> </li> <li> <p>Reinicio tras punto    Despu\u00e9s del parpadeo, la pelota se reinicia en el centro (L3) y comienza a moverse hacia el jugador que meti\u00f3 el punto.</p> </li> <li> <p>Inicio del juego    Al encender, la pelota inicia en L3 y no se mueve hasta que se presione un bot\u00f3n.    Se mover\u00e1 hacia la direcci\u00f3n opuesta del bot\u00f3n presionado.</p> </li> </ol> <p>C\u00f3digo</p> <p><pre><code>#include \"pico/stdlib.h\"\n\n#define LED_1 0\n#define LED_2 1\n#define LED_3 2\n#define LED_4 3\n#define LED_5 4\n\n#define LED_G1 14\n#define LED_G2 15\n\n#define Boton_1 17\n#define Boton_2 16\n\nint led_on = 2; //led con el que comienza el juego\nint direc = 0; //para la direccion +1 izquierda, -1 derecha, negativo porque al comenzar el juego comenzamos a la izquierda\n\n// 0 es no presionado, 1 es presionado\nint boton_d = 0;\nint boton_i = 0;\n\n\n\n\n//esto pasa cuando alguno de los botones se presiono\nvoid juan_perez(uint gpio, uint32_t events){\n    if (gpio == Boton_1) boton_d = 1; //para ver cual de los dos botones se presiono si es el boton1, se le asigna 1 al boton derecho\n    if (gpio == Boton_2) boton_i = 1;\n}\n\nint main() {\n\n    // Poner los leds como salida\n    gpio_init(0); gpio_set_dir(0, 1);\n    gpio_init(1); gpio_set_dir(1, 1);\n    gpio_init(2); gpio_set_dir(2, 1);\n    gpio_init(3); gpio_set_dir(3, 1);\n    gpio_init(4); gpio_set_dir(4, 1);\n\n\n    // Salida\n    gpio_init(LED_G1); gpio_set_dir(LED_G1,1);\n    gpio_init(LED_G2); gpio_set_dir(LED_G2,1);\n\n    // Entrada\n    gpio_init(Boton_1); gpio_set_dir(Boton_1,0);\n    gpio_init(Boton_2); gpio_set_dir(Boton_2,0);\n\n    // GPIO_IRQ_EDGE_RISE significa que se activa la interrupcion cuando el boton se presiona y true es para activar la interrupcion\n    gpio_set_irq_enabled_with_callback(Boton_1, GPIO_IRQ_EDGE_RISE, true, &amp;juan_perez);\n    gpio_set_irq_enabled_with_callback(Boton_2, GPIO_IRQ_EDGE_RISE, true, &amp;juan_perez);\n\n    while (direc == 0) { // mientras que no se haya presionado ningun boton, el led de en medio esta encendido\n      gpio_put(LED_3, 1);\n      if (boton_d) {      //cuando el boton derecho se presiona la variable direc es 1, por lo que la pelota va a la izquierda        \n          direc = 1;   \n          boton_d = 0;\n      }\n      if (boton_i) {\n          direc = -1;  //cuando el boton derecho se presiona la variable direc es -1, por lo que la pelota va a la derecha\n          boton_i = 0; //resetear la variable para que no siga detectando que el boton esta presionado \n      }\n      sleep_ms(10); \n    }\n\n    while (true) {\n        // Apagar los leds para que no se queden encendidos siempre\n        for (int i = LED_1; i &lt;= LED_5; i++) gpio_put(i, 0);\n\n        // Encender el led actual\n        gpio_put(led_on, 1);\n        sleep_ms(500);\n\n\n        if (led_on == 0){   //si el led que esta encendido es el 0, quiere decir que la pelota llego al final izquierdo\n            if(boton_d){  // si se presiona el boton se cambia la direccion de la pelota a la izquierda\n                direc = 1;\n            } else {\n                gpio_put(LED_G2, 1);  // Si no se presiono, el jugador perdio y enciende el led del jugador 2\n                sleep_ms(500);\n                gpio_put(LED_G2, 0);\n                sleep_ms(500);\n                gpio_put(LED_G2, 1);  \n                sleep_ms(500);\n                gpio_put(LED_G2, 0);\n                sleep_ms(500);\n                gpio_put(LED_G2, 1);  \n                sleep_ms(500);\n                gpio_put(LED_G2, 0);\n                led_on = 1;\n                direc = 1; // ahora la pelota va a la izquierda\n\n            }\n            boton_d = 0;  // Resetear la variable del boton derecho\n        }\n        else if (led_on == 4) {\n            if(boton_i){\n                direc = -1;\n            } else {\n                gpio_put(LED_G1, 1);  \n                sleep_ms(500);\n                gpio_put(LED_G1, 0);\n                sleep_ms(500);\n                gpio_put(LED_G1, 1);  \n                sleep_ms(500);\n                gpio_put(LED_G1, 0);\n                sleep_ms(500);\n                gpio_put(LED_G1, 1);  \n                sleep_ms(500);\n                gpio_put(LED_G1, 0);\n                led_on = 3;\n                direc = -1;\n\n            }\n            boton_i = 0;  \n        }\n\n        // Actualizar el led actual\n        led_on += direc;\n    }\n}\n</code></pre> Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p>"},{"location":"SE_1/Tarea5/","title":"Tarea 5","text":""},{"location":"SE_1/Tarea5/#desfase-de-tiempo-con-temporizadores","title":"Desfase de Tiempo con Temporizadores","text":""},{"location":"SE_1/Tarea5/#esquematico-de-conexion","title":"Esquem\u00e1tico de conexi\u00f3n","text":"<p>Esquem\u00e1tico del circuito usado durante la actividad.</p> <p></p>"},{"location":"SE_1/Tarea5/#medicion-en-osciloscopio-del-periodo-y-jitter-usando-alarm0-modo-s","title":"Medici\u00f3n en osciloscopio del periodo y jitter usando ALARM0 (modo \u00b5s)","text":"<p>Genera una onda cuadrada por toggle de un pin de salida en la ISR de ALARM0, con rearme acumulativo y periodo nominal definido por ti (p. ej., 100 \u00b5s\u20135 ms). Mide con osciloscopio:</p> <ul> <li>Periodo promedio y tolerancia.</li> <li>Jitter pico-a-pico y, si tu equipo lo permite, RMS.</li> <li>Describe la configuraci\u00f3n del osciloscopio (acoplamiento, escala de tiempo/voltaje, modo de medici\u00f3n). No cambiar la resoluci\u00f3n del timer (mantener modo \u00b5s).</li> </ul>"},{"location":"SE_1/Tarea5/#codigo","title":"C\u00f3digo","text":"<p>Blink con timer (SDK alto nivel)</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"pico/time.h\"\n\n#define LED_PIN 0\nstatic const int BLINK_MS = 40;  // &lt;-- ajusta tu periodo aqu\u00ed\n\nbool blink_cb(repeating_timer_t *t) {\n    static bool on = false;\n    gpio_put(LED_PIN, on = !on);\n    return true; // seguir repitiendo la alarma\n}\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    repeating_timer_t timer;\n    // Programa una interrupci\u00f3n peri\u00f3dica cada BLINK_MS:\n    add_repeating_timer_ms(BLINK_MS, blink_cb, NULL, &amp;timer);\n\n    while (true) {\n        // El trabajo \"pesado\" deber\u00eda ir aqu\u00ed (no en la ISR).\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"SE_1/Tarea5/#resultado-en-el-osciloscopio","title":"Resultado en el Oscilosc\u00f3pio","text":"<p>La se\u00f1al obtenida tuvo un periodo promedio de 79.76 ms contra el periodo esperado de 80 ms dando como resultado una tolerancia del 0.3%, con un jitter aproximado de 200 \u00b5s y un voltaje de 1.54 v.</p> <p>El oscilosc\u00f3pio se configur\u00f3 con acoplamiento DC, 10 ms/div (zoom 2 ms/div), 1.0 V/div, cursores en tiempo, trigger por flanco.</p>"},{"location":"SE_1/Tarea5/#comparar-jitterprecision-con-osciloscopio-modo-s-vs-modo-ciclos","title":"Comparar jitter/precisi\u00f3n con osciloscopio: modo \u00b5s vs modo ciclos","text":"<p>Genera una se\u00f1al por toggle en la ISR de ALARM0, primero en modo \u00b5s y luego en modo ciclos de clk_sys (mismo periodo nominal). En ambos casos:</p> <ul> <li>Usa rearme acumulativo.</li> <li>Mant\u00e9n el resto del c\u00f3digo id\u00e9ntico.</li> <li>Con el osciloscopio, mide y registra para cada modo:</li> <li>Periodo promedio y desviaci\u00f3n respecto al nominal.</li> <li>Jitter pico-a-pico y/o RMS.</li> <li>Compara resultados y discute el compromiso entre resoluci\u00f3n de tick y horizonte de programaci\u00f3n.</li> </ul>"},{"location":"SE_1/Tarea5/#codigo_1","title":"C\u00f3digo","text":"<p>Para la comparaci\u00f3n se us\u00f3 el c\u00f3digo anterior y el siguiente:</p> <p>Blink con timer de sistema (bajo nivel)</p> <pre><code>// Blink con timer de sistema (bajo nivel): programando ALARM0 e IRQ\n#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n\n#define LED_PIN       0\n#define ALARM_NUM     1  // usaremos la alarma 1\n\n// Calcula el n\u00famero de IRQ para esa alarma \n#define ALARM_IRQ     timer_hardware_alarm_get_irq_num(timer_hw, ALARM_NUM)\n\nstatic volatile uint32_t next_deadline;   // pr\u00f3ximo instante (en us) en 32 bits bajos\n// Por defecto el timer cuenta \u00b5s (no cambiamos la fuente).\nstatic volatile uint32_t intervalo_us = 40000u;    // periodo en microsegundos\n\nvoid on_alarm_irq(void) {\n    // 1) Limpiar el flag de la alarma\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM_NUM);\n\n    // 2) Hacer el trabajo toggle LED\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED_PIN;\n\n    // 3) Rearmar la siguiente alarma con \"deadline acumulativo\"\n    next_deadline += intervalo_us;\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n}\n\nint main() {\n    stdio_init_all();\n\n    // Configura el LED\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, true);\n\n    // \"now\" = 32 bits bajos del contador (tiempo en \u00b5s)\n    uint32_t now_us = timer_hw-&gt;timerawl;          // lectura 32b (low) del contador\n    next_deadline = now_us + intervalo_us;         // primer deadline\n\n    // Programa la alarma\n    timer_hw-&gt;alarm[ALARM_NUM] = next_deadline;\n\n    // Crea un handler exclusivo para ligar el callback a la IRQ de la alarma\n    irq_set_exclusive_handler(ALARM_IRQ, on_alarm_irq);\n    // Habilita dentro del perif\u00e9rico TIMER la fuente de interrupci\u00f3n para la alarma ALARM_NUM inte = interrupt enable\n    hw_set_bits(&amp;timer_hw-&gt;inte, 1u &lt;&lt; ALARM_NUM);\n    //Habilita la IRQ en el NVIC (controlador de interrupciones del n\u00facleo)\n    irq_set_enabled(ALARM_IRQ, true);\n\n    while (true) {\n        // Mant\u00e9n el bucle principal libre; lo pesado va aqu\u00ed, no en la ISR\n        tight_loop_contents();\n    }\n}\n</code></pre>"},{"location":"SE_1/Tarea5/#resultado-en-el-osciloscopio_1","title":"Resultado en el Oscilosc\u00f3pio","text":"<p>La se\u00f1al  del segundo c\u00f3digo tuvo un periodo promedio de 79.968 ms contra el periodo esperado de 80 ms dando como resultado una tolerancia del 0.04%, con un jitter aproximado de 200 \u00b5s y un voltaje de 1.54 v.</p> <p>Se us\u00f3 la misma configuraci\u00f3n en el oscilosc\u00f3pio del ejercicio anterior.</p>"},{"location":"SE_1/Tarea5/#resultados-de-la-comparacion","title":"Resultados de la Comparaci\u00f3n","text":"<p>Comparando ambas se\u00f1ales de 80\u202fms de per\u00edodo ideal, la segunda se\u00f1al es m\u00e1s precisa con un per\u00edodo promedio de 79.968\u202fms con una tolerancia 0.04\u202f% frente a los 79.76\u202fms de la primera y una tolerancia 0.3\u202f%, mientras que el jitter y el voltaje son id\u00e9nticos en ambas, 200\u202f\u00b5s y 1.54\u202fV respectivamente. Esto indica que, aunque ambas son estables, la segunda ofrece una mayor exactitud temporal.</p>"},{"location":"SE_1/Tarea6/","title":"Tarea 6","text":""},{"location":"SE_1/Tarea6/#1-cuatro-alarmas-cuatro-leds-a-distintas-frecuencias","title":"1) Cuatro alarmas / cuatro LEDs a distintas frecuencias","text":"<p>Configurar ALARM0..ALARM3 del timer de sistema en modo \u00b5s. Cada alarma controla un LED distinto con un periodo propio. </p> <p>Se intento activar la cuarta alarma \u201cALARMA3\u201d pero en ning\u00fan momento esta alarma funciono, por lo cual solo se implementaron 3 alarmas. </p> <p>C\u00f3digo</p> <p><pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/irq.h\"\n#include \"hardware/structs/timer.h\"\n#include \"hardware/gpio.h\"\n\n#define LED0_PIN     0   // LED integrado\n#define LED1_PIN     1      \n#define LED2_PIN     2           // LED externo en GPIO 0\n\n#define ALARM0_NUM   0\n#define ALARM1_NUM   1\n#define ALARM2_NUM   2\n\n#define ALARM0_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM0_NUM)\n#define ALARM1_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM1_NUM)\n#define ALARM2_IRQ   timer_hardware_alarm_get_irq_num(timer_hw, ALARM2_NUM)\n\n\n// Pr\u00f3ximos \"deadlines\" (32 bits bajos en \u00b5s) y sus intervalos en \u00b5s\nstatic volatile uint32_t next0_us, next1_us , next2_us;\nstatic const uint32_t INTERVALO0_US = 250000u;\nstatic const uint32_t INTERVALO1_US = 400000u;\nstatic const uint32_t INTERVALO2_US = 800000u;\n\n// ISR para ALARM0\nstatic void on_alarm0_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM0_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED0_PIN;\n    next0_us += INTERVALO0_US;\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n}\n\n// ISR para ALARM1\nstatic void on_alarm1_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM1_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED1_PIN;\n    next1_us += INTERVALO1_US;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n}\n\n// ISR para ALARM2\nstatic void on_alarm2_irq(void) {\n    hw_clear_bits(&amp;timer_hw-&gt;intr, 1u &lt;&lt; ALARM2_NUM);\n    sio_hw-&gt;gpio_togl = 1u &lt;&lt; LED2_PIN;\n    next2_us += INTERVALO2_US;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n}\n\nint main() {\n\n    gpio_init(LED0_PIN);\n    gpio_set_dir(LED0_PIN, GPIO_OUT);\n    gpio_put(LED0_PIN, 0);\n\n    gpio_init(LED1_PIN);\n    gpio_set_dir(LED1_PIN, GPIO_OUT);\n    gpio_put(LED1_PIN, 0);\n\n    gpio_init(LED2_PIN);\n    gpio_set_dir(LED2_PIN, GPIO_OUT);\n    gpio_put(LED2_PIN, 0);\n\n    // Timer de sistema en microsegundos (por defecto source = 0)\n    timer_hw-&gt;source = 0u;\n\n    uint32_t now_us = timer_hw-&gt;timerawl;\n\n    // Primeros deadlines\n    next0_us = now_us + INTERVALO0_US;\n    next1_us = now_us + INTERVALO1_US;\n    next2_us = now_us + INTERVALO2_US;\n\n    // Programa ambas alarmas\n    timer_hw-&gt;alarm[ALARM0_NUM] = next0_us;\n    timer_hw-&gt;alarm[ALARM1_NUM] = next1_us;\n    timer_hw-&gt;alarm[ALARM2_NUM] = next2_us;\n\n    // Limpia flags pendientes antes de habilitar\n    hw_clear_bits(&amp;timer_hw-&gt;intr, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM));\n\n    // Registra handlers exclusivos para cada alarma\n    irq_set_exclusive_handler(ALARM0_IRQ, on_alarm0_irq);\n    irq_set_exclusive_handler(ALARM1_IRQ, on_alarm1_irq);\n    irq_set_exclusive_handler(ALARM2_IRQ, on_alarm2_irq);\n\n    // Habilita fuentes de interrupci\u00f3n en el perif\u00e9rico TIMER\n    hw_set_bits(&amp;timer_hw-&gt;inte, (1u &lt;&lt; ALARM0_NUM) | (1u &lt;&lt; ALARM1_NUM) | (1u &lt;&lt; ALARM2_NUM));\n\n    // Habilita ambas IRQ en el NVIC\n    irq_set_enabled(ALARM0_IRQ, true);\n    irq_set_enabled(ALARM1_IRQ, true);\n    irq_set_enabled(ALARM2_IRQ, true);\n\n    // Bucle principal: todo el parpadeo ocurre en las ISRs\n    while (true) {\n        tight_loop_contents();\n    }\n}\n</code></pre> Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p>"},{"location":"SE_1/Tarea6/#2-modificacion-del-ping-pong","title":"2) Modificaci\u00f3n del Ping Pong","text":"<p>Modificar su pong, para tener dos botones adicionales, que suban y bajen la velocidad del juego sin delay.</p> <p>C\u00f3digo</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/structs/sio.h\"\n#include \"pico/time.h\"\n\n#define LED_1 0\n#define LED_2 1\n#define LED_3 2\n#define LED_4 3\n#define LED_5 4\n\n#define LED_G1 14\n#define LED_G2 15\n\n#define Boton_Len 19\n#define Boton_Rap 18\n\n#define Boton_1 17\n#define Boton_2 16\n\nint led_on = 2; // led con el que comienza el juego\nint direc = 0; //para la direccion +1 izquierda, -1 derecha, negativo porque al comenzar el juego comenzamos a la izquierda\n\n\n// 0 = no presionado, 1 = presionado\nint boton_d = 0;\nint boton_i = 0;\n\nvolatile int velocidad = 450; // variables de velocidad\nconst int velocidad_min = 150;\nconst int velocidad_max = 1050;\nconst int cambio = 150;\n\nrepeating_timer_t timer; // Crear el temporizador\n\n// Funcion del juego\nbool Juego_Ping_Pong(repeating_timer_t *t);\n\n\n//esto pasa cuando alguno de los botones se presiono\nvoid juan_perez(uint gpio, uint32_t events){\n    if (gpio == Boton_1) boton_d = 1;\n    if (gpio == Boton_2) boton_i = 1;\n\n    if (gpio == Boton_Rap &amp;&amp; velocidad &lt; velocidad_max) {\n        velocidad += cambio;\n        cancel_repeating_timer(&amp;timer);// Cancelar el temporizador actual\n        add_repeating_timer_ms(velocidad, Juego_Ping_Pong, NULL, &amp;timer);//la nueva velocidad, que se pasa a la funcion Juego_Ping_Pong, NULL es un puntero que no se usa y &amp;timer es el temporizador que se va a usar\n    }\n    if (gpio == Boton_Len &amp;&amp; velocidad &gt; velocidad_min) {\n        velocidad -= cambio;\n        cancel_repeating_timer(&amp;timer); \n        add_repeating_timer_ms(velocidad, Juego_Ping_Pong, NULL, &amp;timer);\n    }\n}\n\n// Funcion del juego\nbool Juego_Ping_Pong(repeating_timer_t *t) {\n    // Apagar los LEDs\n    for (int i = LED_1; i &lt;= LED_5; i++) gpio_put(i, 0);\n\n    // Encender el LED actual\n    gpio_put(led_on, 1);\n\n    // Si llega a un extremo\n    if (led_on == 0){ \n        if(boton_d){  \n            direc = 1;\n        } else {\n            // Parpadeo del jugador que pierde\n            for (int i=0;i&lt;3;i++){\n                gpio_put(LED_G2, 1); sleep_ms(500);\n                gpio_put(LED_G2, 0); sleep_ms(500);\n            }\n            led_on = 1;\n            direc = 1;\n        }\n        boton_d = 0;\n    }\n    else if (led_on == 4) {\n        if(boton_i){\n            direc = -1;\n        } else {\n            // Parpadeo del jugador que pierde\n            for (int i=0;i&lt;3;i++){\n                gpio_put(LED_G1, 1); sleep_ms(500);\n                gpio_put(LED_G1, 0); sleep_ms(500);\n            }\n            led_on = 3;\n            direc = -1;\n        }\n        boton_i = 0;  \n    }\n\n    // Avanzar la luz\n    led_on += direc;\n    return true; // seguir repitiendo\n}\n\nint main() {\n\n    // Poner los leds como salida\n    for (int i=0;i&lt;=4;i++){ gpio_init(i); gpio_set_dir(i, 1); }\n    gpio_init(LED_G1); gpio_set_dir(LED_G1,1);\n    gpio_init(LED_G2); gpio_set_dir(LED_G2,1);\n\n    // Botones entrada\n    gpio_init(Boton_1); gpio_set_dir(Boton_1,0);\n    gpio_init(Boton_2); gpio_set_dir(Boton_2,0);\n    gpio_init(Boton_Len); gpio_set_dir(Boton_Len,0);\n    gpio_init(Boton_Rap); gpio_set_dir(Boton_Rap,0);\n\n\n    // GPIO_IRQ_EDGE_RISE significa que se activa la interrupcion cuando el boton se presiona y true es para activar la interrupcion\n    gpio_set_irq_enabled_with_callback(Boton_1, GPIO_IRQ_EDGE_RISE, true, &amp;juan_perez);\n    gpio_set_irq_enabled_with_callback(Boton_2, GPIO_IRQ_EDGE_RISE, true, &amp;juan_perez);\n    gpio_set_irq_enabled_with_callback(Boton_Len, GPIO_IRQ_EDGE_RISE, true, &amp;juan_perez);\n    gpio_set_irq_enabled_with_callback(Boton_Rap, GPIO_IRQ_EDGE_RISE, true, &amp;juan_perez);\n\n\n    // Inicio del juego\n    while (direc == 0) {\n        gpio_put(LED_3, 1);\n        if (boton_d) {        \n            direc = 1;  \n            boton_d = 0;\n        }\n        if (boton_i) {\n            direc = -1;  \n            boton_i = 0;\n        }\n        sleep_ms(10);\n    }\n\n    // Inicia el timer con la velocidad inicial\n    add_repeating_timer_ms(velocidad, Juego_Ping_Pong, NULL, &amp;timer);\n\n    while (true) {\n        tight_loop_contents(); // Mantiene el programa corriendo\n    }\n}\n</code></pre> <p>Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p>"},{"location":"SE_1/Tarea7.1/","title":"Tarea 7.1 PWM","text":""},{"location":"SE_1/Tarea7.1/#1-control-de-duty-cycle-motor-dc","title":"1) Control de Duty Cycle \u2014 Motor DC","text":"<ul> <li>Implementar un circuito con un motor DC controlado mediante PWM variando el duty cycle.</li> <li>Usar 2 botones para seleccionar entre 3 velocidades predefinidas (baja, media y alta).</li> <li>Documentar:<ul> <li>Valores de duty usados, con el porque.</li> <li>Circuito</li> <li>C\u00f3digo</li> </ul> </li> </ul> <p>Nota</p> <p>No olvidar que el microcontrolador no entrega suficiente potencia, se debe usar un puente H o driver de motor para conectar el motor DC.</p> <p>Valores de duty usados</p> <p>Velocidad Baja: 250  porque lo que entra en el motor son 12 volts y lo que minimo con lo que se puede alimentar el motor es 3 volts, esto es el 25, por lo tanto el duty cicle m\u00ednimo es el 25%, lo cual es 250. Velocidad Media:512 Velocidad Alta:1023  porque es lo m\u00e1ximo. </p> <p>C\u00f3digo</p> <p><pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n\n#define BOTON1 16\n#define BOTON2 19\n#define MOTOR 0\n#define F_PWM_HZ 2000   // 2 kHz: fuera del rango visible\n#define TOP 1023        // 10 bits de resoluci\u00f3n\n\nint BOTON1ESTADO=0;\nint BOTON2ESTADO=0;\n\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(MOTOR, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(MOTOR);\n    uint chan  = pwm_gpio_to_channel(MOTOR);\n\n    // Calcular divisor\n    float f_clk = 150000000.0f; // 125 MHz\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 1023);\n    pwm_set_enabled(slice, true);\n\n\n    gpio_init(BOTON1); gpio_set_dir(BOTON1,0);\n    gpio_init(BOTON2); gpio_set_dir(BOTON2,0);\n\n    int velocidades[3]={250,512,1023};\n    int velocidad_actual=0;\n\n    while (true) {\n        BOTON1ESTADO=gpio_get(BOTON1);\n        BOTON2ESTADO=gpio_get(BOTON2);\n\n        if (BOTON1ESTADO==1){\n            velocidad_actual++;\n            if (velocidad_actual&gt;2){\n                velocidad_actual=0;\n            }\n            pwm_set_chan_level(slice, chan, velocidades[velocidad_actual]);\n            sleep_ms(300);\n        }\n\n        if (BOTON2ESTADO==1){\n            velocidad_actual--;\n            if (velocidad_actual&lt;0){\n                velocidad_actual=2;\n            }\n            pwm_set_chan_level(slice, chan, velocidades[velocidad_actual]);\n            sleep_ms(300);\n        }\n\n        sleep_ms(10);\n\n\n    }\n}\n</code></pre> Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p>"},{"location":"SE_1/Tarea7_2/","title":"Tarea 7.2 PWM","text":""},{"location":"SE_1/Tarea7_2/#1-control-de-frecuencia-cancion-con-buzzer","title":"1) Control de Frecuencia \u2014 Canci\u00f3n con Buzzer","text":"<p>PUNTO EXTRA</p> <p>PUNTO EXTRA</p> <p>Programar un buzzer piezoel\u00e9ctrico para reproducir una melod\u00eda reconocible.</p> <p>Variar la frecuencia del PWM para las notas, manteniendo el duty en 50 %.</p> <p>Cada nota debe incluir su frecuencia y duraci\u00f3n en el c\u00f3digo.</p> <p>Documentar:</p> <ul> <li>Tabla con notas, frecuencias y duraci\u00f3n usadas.</li> <li>Evidencia en audio o video de la melod\u00eda funcionando.</li> </ul> <p>Recomendaci\u00f3n</p> <p>La mejor frecuencia de trabajo del buzzer es t\u00edpicamente entre 532 Hz y 4 kHz y adaptar las notas a una octava que suene clara en ese rango.</p> <p>Tabla con notas, frecuencias y duraci\u00f3n usadas.</p>"},{"location":"SE_1/Tarea7_2/#notas-musicales","title":"Notas Musicales","text":"NOTA FRECUENCIA DURACI\u00d3N ESTROFA 1 DO 560 125 DO 560 125 DO 560 125 FA 700 200 LA 880 200 ESTROFA 2 DO 560 125 DO 560 125 DO 560 125 FA 700 200 LA 880 200 ESTROFA 3 FA 700 100 FA 700 100 MI 720 100 MI 720 100 RE 600 100 RE 600 100 DO 560 200 ESTROFA 4 DO 560 125 DO 560 125 DO 560 125 MI 720 125 SOL 800 125 ESTROFA 5 DO 560 125 DO 560 125 DO 560 125 MI 720 125 SOL 800 125 ESTROFA 6 SOL 800 125 LA 880 125 SOL 800 125 FA 700 125 MI 720 125 RE 600 125 DO 560 125 <p>C\u00f3digo</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n\n#define LED_PIN 0\n#define TOP 4096\n#define MI  660.0f\n#define SOL 800.0f\n#define DO 560.0f\n#define SI  1000.0f\n#define RE  600.0f\n#define LA  880.0f\n#define FA  700.0f\n#define DO2  525.0f \n#define RE2  1200.0f\n#define NADA 1.0f\n\n#define delay_nota0 100\n#define delay_nota1 125\n#define delay_nota2 200\n#define delay_nota3 350\n#define silencio 100\n#define silencio1 125\n#define silencio3 500\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(LED_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(LED_PIN);\n    uint chan  = pwm_gpio_to_channel(LED_PIN);\n\n    pwm_set_wrap(slice, TOP);\n    pwm_set_chan_level(slice, chan, 2000);\n    pwm_set_enabled(slice, true);\n\n    float f_clk = 150000000.0f;\n    float div;\n\n    while (true) {\n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000);\n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n\n        div = f_clk / (FA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota2);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n\n        div = f_clk / (LA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota2);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000);\n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n\n        div = f_clk / (FA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota2);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n\n        div = f_clk / (LA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota2);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);\n\n    //TERCERA ESTROFA\n\n        div = f_clk / (FA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (FA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (MI * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (MI * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (RE * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (RE * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota0);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio1);  \n\n        div = f_clk / (DO2 * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota2);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio3);  \n\n\n    //CUARTO ESTROFA\n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (MI * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (SOL * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio3);  \n\n\n        //QUINTO ESTROFA\n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (MI * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio);  \n\n        div = f_clk / (SOL * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio3);  \n\n        //SEXTO ESTROFA\n\n        div = f_clk / (SOL * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (LA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (SOL * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (FA * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (MI * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (RE * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(silencio); \n\n        div = f_clk / (DO * (TOP + 1));\n        pwm_set_clkdiv(slice, div);\n        pwm_set_chan_level(slice, chan, 2000); \n        sleep_ms(delay_nota1);\n\n\n        pwm_set_chan_level(slice, chan, 0); \n        sleep_ms(4000); \n\n\n    }\n}\n</code></pre> <p>Video</p>"},{"location":"SE_1/Tarea7_3/","title":"Tarea 7.3 PWM","text":""},{"location":"SE_1/Tarea7_3/#1-generacion-de-senales-senoidal-de-60-hz-con-pwm-filtro-rc","title":"1) Generaci\u00f3n de Se\u00f1ales \u2014 Senoidal de 60 Hz con PWM + Filtro RC","text":"<ul> <li>Entregable Generar una se\u00f1al sinusoidal aproximada de 60 Hz variando el duty cycle del PWM seg\u00fan una funci\u00f3n seno.</li> </ul> <p>Construir un filtro RC pasabajos b\u00e1sico y verificar la se\u00f1al en el osciloscopio:</p> <ul> <li> <p>Capturas de osciloscopio Antes del filtro (PWM) y Despu\u00e9s del filtro.</p> </li> <li> <p>Explicaci\u00f3n de la frecuencia de corte:</p> </li> </ul> <p>El filtro RC se dise\u00f1a para dejar pasar se\u00f1ales de 60 Hz y eliminar las componentes de alta frecuencia que provienen del PWM.</p> <p>La frecuencia de corte (fcf_cfc\u200b) es el punto donde el filtro empieza a atenuar las se\u00f1ales.</p> <p>Matem\u00e1ticamente:</p> <p>En este caso, queremos que fc sea un poco mayor que 60 Hz para que nuestra se\u00f1al sinusoidal de 60 Hz no sea atenuada.</p> <p>Valores recomendados para un fc\u2248100Hz</p> <p>Opci\u00f3n 1: R=2.2\u2009k\u03a9R C=0.68\u2009\u03bcF fc\u2248106Hz.</p> <p>Opci\u00f3n 2: R=1.6\u2009k\u03a9R, C=1\u2009\u03bcF  fc\u2248100Hz</p> <p>Conexion:</p> <ol> <li> <p>La salida de PWM entra en la resistencia.</p> </li> <li> <p>Despu\u00e9s de la resistencia, conectar el capacitor a tierra.</p> </li> <li> <p>El punto entre resistencia y capacitor es la salida filtrada, que se conecta al osciloscopio.</p> </li> </ol> <p>C\u00f3digo</p> <p><pre><code>// pwm_led.c \u2014 Atenuar LED con PWM en GPIO 2\n#include \"pico/stdlib.h\"\n#include \"hardware/pwm.h\"\n#include &lt;math.h&gt;\n\n#define LED_PIN 0\n#define F_PWM_HZ 100   // 2 kHz: fuera del rango visible\n#define TOP 255        // 10 bits de resoluci\u00f3n\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(LED_PIN, GPIO_FUNC_PWM);\n    uint slice = pwm_gpio_to_slice_num(LED_PIN);\n    uint chan  = pwm_gpio_to_channel(LED_PIN);\n\n    // Calcular divisor\n    float f_clk = 125000000.0f; // 125 MHz\n    float div = f_clk / (F_PWM_HZ * (TOP + 1));\n    pwm_set_clkdiv(slice, div);\n    pwm_set_wrap(slice, TOP);\n\n    pwm_set_chan_level(slice, chan, 0);\n    pwm_set_enabled(slice, true);\n\n    // Fade\n    int level = 0, step = 35, dir = +step;\n\n\n    while (true) {\n        pwm_set_chan_level(slice, chan, level);\n\n        level += dir * step;\n        if (level &gt;= TOP) {\n            level = TOP;\n            dir = -1;\n        } else if (level &lt;= 0) {\n            level = 0;\n            dir = 1;\n        }\n\n        sleep_ms(1);\n    }\n}\n</code></pre> Captura</p> <p>SIN FILTRO</p> <p></p> <p>CON FILTRO</p> <p></p>"},{"location":"SE_1/Tarea8/","title":"Tarea 8 UART","text":""},{"location":"SE_1/Tarea8/#1-boton-con-instruccion-led-on-led-off","title":"1) Bot\u00f3n con instrucci\u00f3n \"LED ON - LED OFF\"","text":"<p>Este c\u00f3digo permite encender y apagar un LED mediante un bot\u00f3n f\u00edsico. Cada vez que se presiona el bot\u00f3n, el LED cambia de estado: si est\u00e1 apagado se enciende (\u201cLED ON\u201d) y si est\u00e1 encendido se apaga (\u201cLED OFF\u201d).</p> <p>C\u00f3digo Recepci\u00f3n</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define LED_PIN 2\n\nint main() {\n    stdio_init_all();\n\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_init(UART_ID, BAUD_RATE);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    char buffer[10];\n    int i = 0;\n\n    while (true) {\n        if (uart_is_readable(UART_ID)) {\n            char c = uart_getc(UART_ID);\n\n            if (c == '\\n') {\n                buffer[i] = '\\0';  \n\n                if (strcmp(buffer, \"LED ON\") == 0) {\n                    gpio_put(LED_PIN, 1);\n                    printf(\" LED ON\\n\");\n                } else if (strcmp(buffer, \"LED OFF\") == 0) {\n                    gpio_put(LED_PIN, 0);\n                    printf(\" LED OFF\\n\");\n                }\n\n                i = 0;\n            } else if (i &lt; sizeof(buffer) - 1) {\n                buffer[i++] = c;\n            }\n        }\n    }\n}\n</code></pre> <p>C\u00f3digo Env\u00edo</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\n#define LED_PIN 14        \n#define BUTTON_PIN 3      \n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\nint main() {\n    stdio_init_all();\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n\n    gpio_init(BUTTON_PIN);\n    gpio_set_dir(BUTTON_PIN, GPIO_IN);\n    gpio_pull_up(BUTTON_PIN);\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n\n    bool estado = false;\n    bool presionado_anterior = false;\n\n    while (true) {\n        bool presionado = !gpio_get(BUTTON_PIN);  \n\n        if (presionado &amp;&amp; !presionado_anterior) { \n            estado = !estado;  \n\n            if (estado) {\n                gpio_put(LED_PIN, 1);\n                uart_puts(UART_ID, \"LED ON\\n\");\n                printf(\"LED ON\\n\");\n            } else {\n                gpio_put(LED_PIN, 0);\n                uart_puts(UART_ID, \"LED OFF\\n\");\n                printf(\"LED OFF\\n\");\n            }\n\n            sleep_ms(200); \n        }\n\n        presionado_anterior = presionado;\n    }\n}\n</code></pre> <p>Video</p>"},{"location":"SE_1/Tarea8/#2-terminal-con-instruccion-led-on-led-off","title":"2) Terminal con instrucci\u00f3n \"LED ON - LED OFF\"","text":"<p>Este c\u00f3digo permite controlar el encendido y apagado de un LED desde el monitor serial. El usuario escribe los comandos \u201cLED ON\u201d o \u201cLED OFF\u201d en la terminal, y el microcontrolador ejecuta la acci\u00f3n correspondiente.</p> <p>C\u00f3digo Recepci\u00f3n</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n#define LED_PIN 2\n\nusing namespace std;\n\nstring mensaje = \"\";\n\nint main() {\n    stdio_init_all();\n\n    gpio_init(LED_PIN);\n    gpio_set_dir(LED_PIN, GPIO_OUT);\n    gpio_put(LED_PIN, 0);\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    printf(\"Esperando mensajes...\\n\");\n\n    while (true) {\n        if (uart_is_readable(UART_ID)) {\n            char ch = uart_getc(UART_ID);\n            printf(\"%c\", ch);\n            mensaje += ch;\n\n            if (ch == ';') {\n                string comando = mensaje.substr(0, mensaje.length() - 1);\n\n                if (comando == \"on\") {\n                    gpio_put(LED_PIN, 1);\n                    printf(\"\\nLED ENCENDIDO\\n\");\n                } else if (comando == \"off\") {\n                    gpio_put(LED_PIN, 0);\n                    printf(\"\\nLED APAGADO\\n\");\n                } else {\n                    printf(\"\\nMensaje no reconocido: '%s'\\n\", comando.c_str());\n                }\n\n                mensaje = \"\";\n            }\n        }\n    }\n    return 0;\n}\n</code></pre> <p>C\u00f3digo Env\u00edo</p> <pre><code>#include \"pico/stdlib.h\"\n#include \"hardware/uart.h\"\n#include &lt;stdio.h&gt;\n#include &lt;string&gt;\n\n#define UART_ID uart0\n#define BAUD_RATE 115200\n#define TX_PIN 0\n#define RX_PIN 1\n\nusing namespace std;\n\nstring mensaje = \"\";\n\nint main() {\n    stdio_init_all();\n\n    uart_init(UART_ID, BAUD_RATE);\n    gpio_set_function(TX_PIN, GPIO_FUNC_UART);\n    gpio_set_function(RX_PIN, GPIO_FUNC_UART);\n    uart_set_format(UART_ID, 8, 1, UART_PARITY_NONE);\n\n    sleep_ms(2000);\n    printf(\"\\nConexi\u00f3n lista. Escribe 'on;' o 'off;'.\\n\");\n\n    while (true) {\n        int ch_int = getchar_timeout_us(10000);\n\n        if (ch_int == PICO_ERROR_TIMEOUT) {\n            continue;\n        }\n\n        char ch = (char)ch_int;\n\n        if (ch == '\\r' || ch == '\\n') {\n            continue;\n        }\n\n        mensaje += ch;\n\n        if (ch == ';') {\n            string comando = mensaje.substr(0, mensaje.length() - 1);\n\n            if (comando == \"on\" || comando == \"off\") {\n                printf(\"Instrucci\u00f3n: %s\\n\", mensaje.c_str());\n                uart_puts(UART_ID, mensaje.c_str());\n            } else {\n                printf(\"Instrucci\u00f3n inv\u00e1lida: '%s'\\n\", comando.c_str());\n            }\n\n            mensaje = \"\";\n        }\n    }\n    return 0;\n}\n</code></pre> <p>Video</p>"},{"location":"SE_1/Tarea9.1/","title":"Tarea 9.1","text":""},{"location":"SE_1/Tarea9.1/#1-adc-luxometro","title":"1) ADC Luxometro","text":"<p>El sensor LDR cambiar\u00e1 su resistencia dependiendo de la intensidad de la luz. Cuando haya m\u00e1s luz, el valor ser\u00e1 mayor; cuando haya oscuridad, ser\u00e1 menor. El programa tomar\u00e1 esa lectura, la convertir\u00e1 en un valor porcentual de 0% (oscuridad total) a 100% (luz m\u00e1xima) y mostrar\u00e1 el resultado en el monitor serial.</p> <p>C\u00f3digo</p> <p><pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n\n// Configurar el canal ADC a usar\n#define ADC_INPUT 0 // canal 0\n// n\u00famero de muestras para promediar\n#define N_muestras 16 \n\nint main() {\n    stdio_init_all();\n    adc_init();\n    // Configura el pin GPIO correspondiente como entrada ADC\n    adc_gpio_init(26); // GPIO26 suele mapear a ADC0 en Pico 2\n    // Seleccionar canal\n    adc_select_input(ADC_INPUT);\n\n    // -- Variables --\n    uint16_t buffer[N_muestras];\n    uint32_t sum = 0; \n    uint8_t  indice = 0;              // proxima posicion a sobrescribir\n    uint8_t  cuenta = 0;            // numero de muestras llenas hasta N_muestras\n\n    while (true) {\n        uint16_t adc = adc_read(); // 12 bits alineados a 0..4095\n        if (cuenta &lt; N_muestras) {\n            // llenar buffer inicialmente\n            buffer[indice] = adc;\n            sum += adc;\n            cuenta++;\n            indice++;\n        } else {\n            // buffer lleno, proceder con media movil\n            sum -= buffer[indice];         // restar valor viejo\n            buffer[indice] = adc;          // agregar nuevo valor al buffer\n            sum += adc;                 // sumar nuevo valor al total\n            // Avance en el buffer circular\n            indice++;\n            if (indice &gt;= N_muestras) indice = 0;\n            // calcular promedio\n            uint16_t promedio = sum / N_muestras; \n\n            printf(\"%u\\n\", promedio);\n            sleep_ms(10);\n            if (promedio &lt; 450) promedio = 0;           // No permitir valores negativos\n            if (promedio &gt; 3900) promedio = 100;     // No permitir valores mayores a 4095\n\n            int porcentaje = (promedio * 100) / 3900;\n\n            printf(\"Porcentaje de luz: %d%%\\n\", porcentaje);\n\n\n        }\n\n    }\n\n}\n</code></pre> Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p>"},{"location":"SE_1/Tarea9.2/","title":"Tarea 9.2","text":""},{"location":"SE_1/Tarea9.2/#1-servo-con-adc","title":"1) Servo con ADC","text":"<p>El potenci\u00f3metro funcionar\u00e1 como un control manual que permitir\u00e1 variar la posici\u00f3n del servomotor de manera proporcional.</p> <p>El valor anal\u00f3gico le\u00eddo por el ADC (convertidor anal\u00f3gico-digital) del Arduino ser\u00e1 mapeado a un rango de 0 a 180 grados, haciendo que el eje del servo se mueva suavemente conforme se gira el potenci\u00f3metro.</p> <p>C\u00f3digo</p> <p><pre><code>#include &lt;stdio.h&gt;\n#include \"pico/stdlib.h\"\n#include \"hardware/adc.h\"\n#include \"hardware/pwm.h\"\n\n#define ADC_INPUT 0 \n#define SERVO_PIN 15 // 2 kHz: fuera del rango visible\n#define TOP 1023\nuint slice_num; \n\nvoid configurar_servo() {\n    // Configura el pin como salida PWM\n    gpio_set_function(SERVO_PIN, GPIO_FUNC_PWM);\n\n    // Obtiene el n\u00famero de slice PWM asignado al pin\n    slice_num = pwm_gpio_to_slice_num(SERVO_PIN);\n\n    // Divisor de clock para ticks de 1\u00b5s (125MHz/125 = 1MHz)\n    pwm_set_clkdiv(slice_num, 125.0f);\n\n    // Configura periodo de 20ms (20000\u00b5s) para frecuencia de 50Hz\n    pwm_set_wrap(slice_num, 20000);\n\n    // Habilita la salida PWM\n    pwm_set_enabled(slice_num, true);\n\n}\n\n\nvoid mover_servo(int adc) {\n    // Limita el valor del ADC al rango v\u00e1lido\n    if (adc &lt; 0) adc = 0;           // No permitir valores negativos\n    if (adc &gt; 4095) adc = 4095;     // No permitir valores mayores a 4095\n\n    int angulo = (adc * 180) / 4095;\n\n    // Convierte \u00e1ngulo a ancho de pulso:\n    // - M\u00ednimo: 500\u00b5s (0 grados)\n    // - M\u00e1ximo: 2500\u00b5s (180 grados)\n    int pulso_us = 500 + (angulo * 2000) / 180;\n\n    // Aplica el ancho de pulso al PWM\n    pwm_set_gpio_level(SERVO_PIN, pulso_us);\n\n    // Muestra el \u00e1ngulo actual por consola\n    printf(\"Servo en %d\u00b0\\n\", angulo);\n    }\n\n\nint main() {\n    stdio_init_all();\n    adc_init();\n    adc_gpio_init(26); \n    adc_select_input(ADC_INPUT);\n\n    configurar_servo();\n\n    while (true) {\n        uint16_t adc = adc_read();\n        int angulo = (adc * 180) / 4095;\n        printf(\"%u\\n\", adc);\n        mover_servo(adc);\n        sleep_ms(10);\n    }\n}\n</code></pre> Esquematico de conexi\u00f3n</p> <p></p> <p>Video</p>"}]}